{
    "docs": [
        {
            "location": "/", 
            "text": "Product Overview\n\n\nAbout Kontext and how to get started\n\n\nWhat is Kontext?\n\n\nKontext enables you to integrate app analytics and marketing. \n\n\nOur platform helps you increase user engagement in three ways: \n\n\n\n\nYou can track actions users are taking in your app to analyze how people use your product. \n\n\nYou can segment users based on their actions and run targeted campaigns to these segments. \n\n\nYou can analyze each of your campaigns to understand their impact on user engagement and your business metrics.\n\n\n\n\nPlatform Features\n\n\nThere are five parts of the Kontext platform: \n\n\n\n\nEASY TO USE\n\u00a0- Implementing reliable interfaces to the GCM/FCM (Google), APNS (Apple), and the Web Push protocols is difficult. There are open source projects to do it, but even the best ones break when message quantity begins to exceed 500,000 at a time.\n\n\nSDKs\n that let you track users\u2019 actions within your mobile apps and websites. Our SDKs also enable you to personalize your app by giving you access to user profile data.\n\n\nDASHBOARD\n where you can segment your users based on their actions, run targeted campaigns to these segments, and analyze each campaign\u2019s performance. \n\n\nADVANCED FUNCTIONALITY\n\u00a0- Kontext provides marketing tools including A/B testing, segment targeting, variable-substitution, localization, drip marketing, and conversion tracking.\n\n\nWEBHOOKS\n that let you trigger workflows in your backend systems as soon as qualifying events occur.\n\n\n\n\nCore Concepts\n\n\nUsers, events, segments, campaigns, and reports are central to the Kontext experience, so it is important to understand each one's role. \n\n\n\n\nUsers:\n After you integrate the Kontext SDK, a user profile will be created for each person who launches your app or visits your website. The Kontext user profile has a set of default fields, such as device and location. You can also extend the default user profile data model by adding custom fields that are specific to your business.\n\n\nEvents:\n The Kontext SDK lets you track what actions users perform in your app or website, such as a user viewing a product, listening to a song, or making a purchase. Events are associated with a user profile.\n\n\nSegments:\n Kontext enables you to create segments, which are a group of users whose behaviors, activities, or user profile properties meet a set of criteria you\u2019ve defined. Once you\u2019ve identified segments of interest, you can save them, target them with a campaign, and then analyze them over time. \n\n\nCampaigns:\n Kontext campaigns enable you to communicate with your users at scale. Kontext offers 3 different messaging channels to reach your users with the right message at the right time.\n\n\nReports:\n Kontext lets you build reports to understand the impact of your campaigns on your users. You can use these reports to analyze your user engagement and guide product decisions.\n\n\n\n\nHow do I get started?\n\n\n\n\nGo to our \nAndroid\n or \niOS\n setup guides to get started implementing Kontext in your product today!", 
            "title": "Overview"
        }, 
        {
            "location": "/#product-overview", 
            "text": "About Kontext and how to get started", 
            "title": "Product Overview"
        }, 
        {
            "location": "/#what-is-kontext", 
            "text": "Kontext enables you to integrate app analytics and marketing.   Our platform helps you increase user engagement in three ways:    You can track actions users are taking in your app to analyze how people use your product.   You can segment users based on their actions and run targeted campaigns to these segments.   You can analyze each of your campaigns to understand their impact on user engagement and your business metrics.", 
            "title": "What is Kontext?"
        }, 
        {
            "location": "/#platform-features", 
            "text": "There are five parts of the Kontext platform:    EASY TO USE \u00a0- Implementing reliable interfaces to the GCM/FCM (Google), APNS (Apple), and the Web Push protocols is difficult. There are open source projects to do it, but even the best ones break when message quantity begins to exceed 500,000 at a time.  SDKs  that let you track users\u2019 actions within your mobile apps and websites. Our SDKs also enable you to personalize your app by giving you access to user profile data.  DASHBOARD  where you can segment your users based on their actions, run targeted campaigns to these segments, and analyze each campaign\u2019s performance.   ADVANCED FUNCTIONALITY \u00a0- Kontext provides marketing tools including A/B testing, segment targeting, variable-substitution, localization, drip marketing, and conversion tracking.  WEBHOOKS  that let you trigger workflows in your backend systems as soon as qualifying events occur.", 
            "title": "Platform Features"
        }, 
        {
            "location": "/#core-concepts", 
            "text": "Users, events, segments, campaigns, and reports are central to the Kontext experience, so it is important to understand each one's role.    Users:  After you integrate the Kontext SDK, a user profile will be created for each person who launches your app or visits your website. The Kontext user profile has a set of default fields, such as device and location. You can also extend the default user profile data model by adding custom fields that are specific to your business.  Events:  The Kontext SDK lets you track what actions users perform in your app or website, such as a user viewing a product, listening to a song, or making a purchase. Events are associated with a user profile.  Segments:  Kontext enables you to create segments, which are a group of users whose behaviors, activities, or user profile properties meet a set of criteria you\u2019ve defined. Once you\u2019ve identified segments of interest, you can save them, target them with a campaign, and then analyze them over time.   Campaigns:  Kontext campaigns enable you to communicate with your users at scale. Kontext offers 3 different messaging channels to reach your users with the right message at the right time.  Reports:  Kontext lets you build reports to understand the impact of your campaigns on your users. You can use these reports to analyze your user engagement and guide product decisions.", 
            "title": "Core Concepts"
        }, 
        {
            "location": "/#how-do-i-get-started", 
            "text": "Go to our  Android  or  iOS  setup guides to get started implementing Kontext in your product today!", 
            "title": "How do I get started?"
        }, 
        {
            "location": "/android-quickstart/", 
            "text": "Android SDK Setup\n\n\n\n\nUpgrade to 3.5.1+\n\n\nA number the methods and classes below were recently added in our 3.5.1 SDK. Make sure you have updated to this version.\n\n\n\n\nRequired For Setup\n\n\n\n\nA Kontext Account\n, if you do not already have one\n\n\nYour Kontext App ID, available in \nKeys \n IDs\n\n\nA Google/Firebase Server API Key\n\n\nA device or emulator that has Google Play services installed and updated on it\n\n\nAndroid Studio 2.3.3 or newer\n\n\n\n\n1. Download the SDK\n\n\nClick Here to download the SDK\n\n\n2. Gradle Setup\n\n\n2.1\n Place Kontext SDK in your app's \nlibs\n folder.\n\n\n2.2\n Add the following to your \ndependencies\n section.\n\n\n\n\nbuild.gradle\n\n\n\n\n1\n2\n3\n4\n5\ndependencies {\n    implementation(name:\nkontextSdk\n, ext:\naar\n)\n    implementation \ncom.google.android.gms:play-services-nearby:12.0.1\n\n    implementation \ncom.android.installreferrer:installreferrer:1.0\n\n}\n\n\n\n\n\n\n\n\nPlay Services Version\n\n\nIn order to get access to all Kontext SDK features update all your app play services version to 12.0.1 or above.\n\n\n\n\n2.3\n Add the following in your \nandroid\n \n \ndefaultConfig\n section.\n\n\n\n\n\n\nUpdate \nPUT YOUR KONTEXT APP ID HERE\n with your Kontext app id\n\n\n\n\n\n\nbuild.gradle\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nandroid {\n   defaultConfig {\n      manifestPlaceholders = [\n          kontext_app_id: \nPUT YOUR KONTEXT APP ID HERE\n,\n          // Project number pulled from dashboard, local value is ignored.\n          kontext_google_project_number: \nREMOTE\n\n      ]\n    }\n }\n\n\n\n\n\n2.4\n Add the following in your \nApp Manifest application\n tag to enable Kontext In-App messaging.\n\n\n1\n2\n3\n4\n5\n6\napplication\n\n    \nactivity\n\n    \nandroid:name=\ncom.kontext.InAppMessageActivity\n\n    \nandroid:configChanges=\norientation|keyboardHidden\n\n    \nandroid:theme=\n@android:style/Theme.Translucent.NoTitleBar\n \n/\n\n\n/application\n\n\n\n\n\n\n\nSync Gradle\n\n\nMake sure to press \"Sync Now\" on the banner that pops up after saving!\n\n\n3. Add Required Code\n\n\n3.1\n Add the following to the \nonCreate\n method in your \nApplication\n class.\n\n\n\n\nDon't have an Application class? Follow our creation guide!\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nimport\n \ncom.kontext.Kontext\n;\n\n\n\npublic\n \nclass\n \nYourAppClass\n \nextends\n \nApplication\n \n{\n\n   \n@Override\n\n   \npublic\n \nvoid\n \nonCreate\n()\n \n{\n\n      \nsuper\n.\nonCreate\n();\n\n\n      \n// Kontext Initialization\n\n      \nKontext\n.\nstartInit\n(\nthis\n)\n\n        \n.\ninFocusDisplaying\n(\nKontext\n.\nOSInFocusDisplayOption\n.\nNotification\n)\n\n        \n.\nunsubscribeWhenNotificationsAreDisabled\n(\ntrue\n)\n\n        \n.\ninit\n();\n\n   \n}\n\n\n}\n\n\n\n\n\n\n\n4. Create a custom default notification icon\n\n\n4.1\n By default, notifications will be shown with a bell icon in the notification shade. \n\n\n\n\nTroubleshooting\n\n\nIf run into any issues please see our \nAndroid troubleshooting guide\n, or our general Troubleshooting section.\n\n\n\n\n5. Add Information to a User Profile\n\n\nRECOMMENDED\n\n\nA User Profile is automatically created in Kontext for each user launching your application.\n\n\nInitially, the User Profile starts out as anonymous, which means the profile does not contain any identifiable information about the user. You can enrich the profile with pre-defined attributes from the Kontext data model, such as name and email. You can also add custom attributes that you define to extend the Kontext data model.\n\n\nSending user profile information to Kontext using our Android SDK requires two steps. First, you have to build a JSON Object with the profile properties. Second, you have to call the SDK's \nsendUserAttributes\n) method and pass the object you created as a parameter.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nJSONObject\n \nuserProfile\n \n=\n \nnew\n \nJSONObject\n();\n\n      \ntry\n \n{\n\n         \nuserProfile\n.\nput\n(\nName\n,\n \nJhon Doe\n);\n\n         \nuserProfile\n.\nput\n(\nEmail\n,\n \njack@gmail.com\n);\n\n         \nuserProfile\n.\nput\n(\nPhone\n,\n \n+14155551234\n);\n\n         \nuserProfile\n.\nput\n(\nGender\n,\n \nM\n);\n\n         \nuserProfile\n.\nput\n(\nEmployed\n,\n \nY\n);\n\n         \nuserProfile\n.\nput\n(\nEducation\n,\n \nGraduate\n);\n\n         \nuserProfile\n.\nput\n(\nMarried\n,\nY\n);\n\n         \nuserProfile\n.\nput\n(\nAge\n,\n \n50\n);\n\n         \nuserProfile\n.\nput\n(\nTz\n,\n \nAsia/Kolkata\n);\n\n         \nKontext\n.\nsetUserAttributes\n(\nuserProfile\n);\n\n      \n}\n \ncatch\n \n(\nJSONException\n \ne\n)\n \n{\n\n         \ne\n.\nprintStackTrace\n();\n\n      \n}\n\n\n\n\n\n\n\n6. Track Screen Activity\n\n\nRECOMMENDED\n\n\nOnce you integrate the Kontext SDK, we automatically start tracking events, such as App Launch and Notification Viewed. Kontext SDK offers screen tracking API to track screen activity of a user.\n\n\nTo send screen activity to Kontext, you will have to call the \nsendScreen\n method with the name of the screen.\n\n\n1\nKontext\n.\nsendScreen\n(\nScreen Name\n);\n\n\n\n\n\n\n\n7. Track Custom Events\n\n\nRECOMMENDED\n\n\nOnce you integrate the Kontext SDK, we automatically start tracking events, such as App Launch and Notification Viewed. In addition, you can also track custom events.\n\n\nTo send screen activity to Kontext, you will have to call the \nsendEvent\n method with the name of the custom event you want to track.\n\n\n1\nKontext\n.\nsendEvent\n(\nProduct Added\n,\n \nApplie iPhone\n);\n\n\n\n\n\n\n\n\n\nYou're Done!\n\n\nNext up: Send your first push notification via the \nKontext Dashboard", 
            "title": "Android Quickstart"
        }, 
        {
            "location": "/android-quickstart/#android-sdk-setup", 
            "text": "Upgrade to 3.5.1+  A number the methods and classes below were recently added in our 3.5.1 SDK. Make sure you have updated to this version.", 
            "title": "Android SDK Setup"
        }, 
        {
            "location": "/android-quickstart/#required-for-setup", 
            "text": "A Kontext Account , if you do not already have one  Your Kontext App ID, available in  Keys   IDs  A Google/Firebase Server API Key  A device or emulator that has Google Play services installed and updated on it  Android Studio 2.3.3 or newer", 
            "title": "Required For Setup"
        }, 
        {
            "location": "/android-quickstart/#1-download-the-sdk", 
            "text": "Click Here to download the SDK", 
            "title": "1. Download the SDK"
        }, 
        {
            "location": "/android-quickstart/#2-gradle-setup", 
            "text": "2.1  Place Kontext SDK in your app's  libs  folder.  2.2  Add the following to your  dependencies  section.   build.gradle   1\n2\n3\n4\n5 dependencies {\n    implementation(name: kontextSdk , ext: aar )\n    implementation  com.google.android.gms:play-services-nearby:12.0.1 \n    implementation  com.android.installreferrer:installreferrer:1.0 \n}    Play Services Version  In order to get access to all Kontext SDK features update all your app play services version to 12.0.1 or above.   2.3  Add the following in your  android     defaultConfig  section.    Update  PUT YOUR KONTEXT APP ID HERE  with your Kontext app id    build.gradle    1\n2\n3\n4\n5\n6\n7\n8\n9 android {\n   defaultConfig {\n      manifestPlaceholders = [\n          kontext_app_id:  PUT YOUR KONTEXT APP ID HERE ,\n          // Project number pulled from dashboard, local value is ignored.\n          kontext_google_project_number:  REMOTE \n      ]\n    }\n }   2.4  Add the following in your  App Manifest application  tag to enable Kontext In-App messaging.  1\n2\n3\n4\n5\n6 application \n     activity \n     android:name= com.kontext.InAppMessageActivity \n     android:configChanges= orientation|keyboardHidden \n     android:theme= @android:style/Theme.Translucent.NoTitleBar   /  /application", 
            "title": "2. Gradle Setup"
        }, 
        {
            "location": "/android-quickstart/#sync-gradle", 
            "text": "Make sure to press \"Sync Now\" on the banner that pops up after saving!", 
            "title": "Sync Gradle"
        }, 
        {
            "location": "/android-quickstart/#3-add-required-code", 
            "text": "3.1  Add the following to the  onCreate  method in your  Application  class.   Don't have an Application class? Follow our creation guide!    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 import   com.kontext.Kontext ;  public   class   YourAppClass   extends   Application   { \n    @Override \n    public   void   onCreate ()   { \n       super . onCreate (); \n\n       // Kontext Initialization \n       Kontext . startInit ( this ) \n         . inFocusDisplaying ( Kontext . OSInFocusDisplayOption . Notification ) \n         . unsubscribeWhenNotificationsAreDisabled ( true ) \n         . init (); \n    }  }", 
            "title": "3. Add Required Code"
        }, 
        {
            "location": "/android-quickstart/#4-create-a-custom-default-notification-icon", 
            "text": "4.1  By default, notifications will be shown with a bell icon in the notification shade.    Troubleshooting  If run into any issues please see our  Android troubleshooting guide , or our general Troubleshooting section.", 
            "title": "4. Create a custom default notification icon"
        }, 
        {
            "location": "/android-quickstart/#5-add-information-to-a-user-profile", 
            "text": "RECOMMENDED  A User Profile is automatically created in Kontext for each user launching your application.  Initially, the User Profile starts out as anonymous, which means the profile does not contain any identifiable information about the user. You can enrich the profile with pre-defined attributes from the Kontext data model, such as name and email. You can also add custom attributes that you define to extend the Kontext data model.  Sending user profile information to Kontext using our Android SDK requires two steps. First, you have to build a JSON Object with the profile properties. Second, you have to call the SDK's  sendUserAttributes ) method and pass the object you created as a parameter.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 JSONObject   userProfile   =   new   JSONObject (); \n       try   { \n          userProfile . put ( Name ,   Jhon Doe ); \n          userProfile . put ( Email ,   jack@gmail.com ); \n          userProfile . put ( Phone ,   +14155551234 ); \n          userProfile . put ( Gender ,   M ); \n          userProfile . put ( Employed ,   Y ); \n          userProfile . put ( Education ,   Graduate ); \n          userProfile . put ( Married , Y ); \n          userProfile . put ( Age ,   50 ); \n          userProfile . put ( Tz ,   Asia/Kolkata ); \n          Kontext . setUserAttributes ( userProfile ); \n       }   catch   ( JSONException   e )   { \n          e . printStackTrace (); \n       }", 
            "title": "5. Add Information to a User Profile"
        }, 
        {
            "location": "/android-quickstart/#6-track-screen-activity", 
            "text": "RECOMMENDED  Once you integrate the Kontext SDK, we automatically start tracking events, such as App Launch and Notification Viewed. Kontext SDK offers screen tracking API to track screen activity of a user.  To send screen activity to Kontext, you will have to call the  sendScreen  method with the name of the screen.  1 Kontext . sendScreen ( Screen Name );", 
            "title": "6. Track Screen Activity"
        }, 
        {
            "location": "/android-quickstart/#7-track-custom-events", 
            "text": "RECOMMENDED  Once you integrate the Kontext SDK, we automatically start tracking events, such as App Launch and Notification Viewed. In addition, you can also track custom events.  To send screen activity to Kontext, you will have to call the  sendEvent  method with the name of the custom event you want to track.  1 Kontext . sendEvent ( Product Added ,   Applie iPhone );     You're Done!  Next up: Send your first push notification via the  Kontext Dashboard", 
            "title": "7. Track Custom Events"
        }, 
        {
            "location": "/iOS-quickstart/", 
            "text": "iOS SDK Setup\n\n\n\n\nUpgrade to 2.5.1+\n\n\nA number the methods and classes below were recently added in our 3.5.1 SDK. Make sure you have updated to this version.\n\n\n\n\nRequired For Setup\n\n\n\n\nA Kontext Account\n if you do not already have one\n\n\nYour Kontext App ID, available in \nKeys \n IDs\n\n\nAn iOS Push Certificate. \nGenerate one here\n.\n\n\nAn iOS device (iPhone, iPad, iPod Touch) to test on. The Xcode simulator doesn't support push notifications so you must test on a real device.\n\n\nA Mac with a new version of Xcode\n\n\n\n\n1. Download the SDK\n\n\nClick Here to download the SDK\n\n\n2. Add Notification Service Extension\n\n\n2.1\n In Xcode Select \nFile\n \n \nNew\n \n \nTarget...\n\n\n2.2\n Select \nNotification Service Extension\n then press \nNext\n.\n\n\nIMAGE\n\n\n2.3\n\u00a0Enter the product name as\u00a0\nKontextNotificationServiceExtension\n\u00a0and press\u00a0\nFinish\n.\n\n\nIMAGE\n\n\n2.4\n\u00a0Press Cancel on the Activate scheme prompt.\n\n\nIMAGE\n\n\nBy cancelling, you are keeping Xcode debugging your app, instead of just the extension. If you activate by accident, you can always switch back to debug your app within Xcode (next to the play button).\n\n\n2.5\n Open the Xcode project settings and select the KontextNotificationServiceExtension target. Unless you have a specific reason not to, you should set the \nDeployment Target\n to be iOS 10.\n\n\nIMAGE\n\n\n2.6\n\u00a0Open\u00a0\nNotificationService.m\n\u00a0or\u00a0\nNotificationService.swift\n\u00a0and replace the whole file contents with the below code.\n\n\n\n\n\n\nSwift\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\nimport\n \nUserNotifications\n\n\n\nimport\n \nKontext\n\n\n\nclass\n \nNotificationService\n:\n \nUNNotificationServiceExtension\n \n{\n\n\n    \nvar\n \ncontentHandler\n:\n \n((\nUNNotificationContent\n)\n \n-\n \nVoid\n)?\n\n    \nvar\n \nreceivedRequest\n:\n \nUNNotificationRequest\n!\n\n    \nvar\n \nbestAttemptContent\n:\n \nUNMutableNotificationContent\n?\n\n\n    \noverride\n \nfunc\n \ndidReceive\n(\n_\n \nrequest\n:\n \nUNNotificationRequest\n,\n \nwithContentHandler\n \ncontentHandler\n:\n \n@\nescaping\n \n(\nUNNotificationContent\n)\n \n-\n \nVoid\n)\n \n{\n\n        \nself\n.\nreceivedRequest\n \n=\n \nrequest\n;\n\n        \nself\n.\ncontentHandler\n \n=\n \ncontentHandler\n\n        \nbestAttemptContent\n \n=\n \n(\nrequest\n.\ncontent\n.\nmutableCopy\n()\n \nas\n?\n \nUNMutableNotificationContent\n)\n\n\n        \nif\n \nlet\n \nbestAttemptContent\n \n=\n \nbestAttemptContent\n \n{\n\n            \nKontext\n.\ndidReceiveNotificationExtensionRequest\n(\nself\n.\nreceivedRequest\n,\n \nwith\n:\n \nself\n.\nbestAttemptContent\n)\n\n            \ncontentHandler\n(\nbestAttemptContent\n)\n\n        \n}\n\n    \n}\n\n\n    \noverride\n \nfunc\n \nserviceExtensionTimeWillExpire\n()\n \n{\n\n        \n// Called just before the extension will be terminated by the system.\n\n        \n// Use this as an opportunity to deliver your \nbest attempt\n at modified content, otherwise the original push payload will be used.\n\n        \nif\n \nlet\n \ncontentHandler\n \n=\n \ncontentHandler\n,\n \nlet\n \nbestAttemptContent\n \n=\n  \nbestAttemptContent\n \n{\n\n            \nKontext\n.\nserviceExtensionTimeWillExpireRequest\n(\nself\n.\nreceivedRequest\n,\n \nwith\n:\n \nself\n.\nbestAttemptContent\n)\n\n            \ncontentHandler\n(\nbestAttemptContent\n)\n\n        \n}\n\n    \n}\n\n\n\n}\n\n\n\n\n\n\n\n\nObjective-C\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n#import \nKontext/Kontext.h\n\n\n\n#import \nNotificationService.h\n\n\n\n@interface\n \nNotificationService\n \n()\n\n\n\n@property\n \n(\nnonatomic\n,\n \nstrong\n)\n \nvoid\n \n(\n^\ncontentHandler\n)(\nUNNotificationContent\n \n*\ncontentToDeliver\n);\n\n\n@property\n \n(\nnonatomic\n,\n \nstrong\n)\n \nUNNotificationRequest\n \n*\nreceivedRequest\n;\n\n\n@property\n \n(\nnonatomic\n,\n \nstrong\n)\n \nUNMutableNotificationContent\n \n*\nbestAttemptContent\n;\n\n\n\n@end\n\n\n\n@implementation\n \nNotificationService\n\n\n\n-\n \n(\nvoid\n)\ndidReceiveNotificationRequest:\n(\nUNNotificationRequest\n \n*\n)\nrequest\n \nwithContentHandler:\n(\nvoid\n \n(\n^\n)(\nUNNotificationContent\n \n*\n \n_Nonnull\n))\ncontentHandler\n \n{\n\n    \nself\n.\nreceivedRequest\n \n=\n \nrequest\n;\n\n    \nself\n.\ncontentHandler\n \n=\n \ncontentHandler\n;\n\n    \nself\n.\nbestAttemptContent\n \n=\n \n[\nrequest\n.\ncontent\n \nmutableCopy\n];\n\n\n    \n[\nKontext\n \ndidReceiveNotificationExtensionRequest\n:\nself\n.\nreceivedRequest\n \nwithMutableNotificationContent\n:\nself\n.\nbestAttemptContent\n];\n\n\n    \n// DEBUGGING: Uncomment the 2 lines below and comment out the one above to ensure this extension is excuting\n\n    \n//            Note, this extension only runs when mutable-content is set\n\n    \n//            Setting an attachment or action buttons automatically adds this\n\n    \n// NSLog(@\nRunning NotificationServiceExtension\n);\n\n    \n// self.bestAttemptContent.body = [@\n[Modified] \n stringByAppendingString:self.bestAttemptContent.body];\n\n\n    \nself\n.\ncontentHandler\n(\nself\n.\nbestAttemptContent\n);\n\n\n}\n\n\n\n-\n \n(\nvoid\n)\nserviceExtensionTimeWillExpire\n \n{\n\n    \n// Called just before the extension will be terminated by the system.\n\n    \n// Use this as an opportunity to deliver your \nbest attempt\n at modified content, otherwise the original push payload will be used.\n\n\n    \n[\nKontext\n \nserviceExtensionTimeWillExpireRequest\n:\nself\n.\nreceivedRequest\n \nwithMutableNotificationContent\n:\nself\n.\nbestAttemptContent\n];\n\n\n    \nself\n.\ncontentHandler\n(\nself\n.\nbestAttemptContent\n);\n\n\n}\n\n\n\n@end\n\n\n\n\n\n\n\n\nIgnore any build errors at this point, step 2 will import Kontext which will resolve any errors.\n\n\n3. Import Kontext into your Xcode project\n\n\nSetup CocoaPods\n on your system if you don't have it already.\n\n\n\n\nMake sure you have version \n1.1.0\n or newer by running \npod --version\n from the terminal.\n\n\nRun the following to upgrade \nsudo gem install cocoapods\n\n\n\n\n3.1\n Make sure your current Xcode project is closed.\n\n\n3.2\n Run \npod init\n from the terminal in your project directory.\n\n\n3.3\n Open the newly created \nPodfile\n with your favorite code editor such as Sublime.\n\n\n3.4\n Add \npod \nKontext\n, \n= 2.5.2\n, \n 3.0\n in your project name target as well as \nKontextNotificationServiceExtension\n.\n\n\n1\n2\n3\n4\n5\n6\n7\ntarget \nproject_name\n do\n  pod \nKontext\n, \n= 2.6.2\n, \n 3.0\n\nend\n\ntarget \nKontextNotificationServiceExtension\n do\n  pod \nKontext\n, \n= 2.6.2\n, \n 3.0\n\nend\n\n\n\n\n\n\n3.5\n\u00a0Run the following from the terminal.\n\n\n1\n2\npod repo update\npod install\n\n\n\n\n\n\n3.6\n\u00a0Open the newly created\u00a0\n.xcworkspace\n\u00a0file. \nMake sure to always open the workspace from now on.\n \n\n\n3.7\n\u00a0Continue to Steps 3 and 4 below\n\n\n4. Add Required Capabilities\n\n\n4.1\n Select the root project and Under Capabilities Enable \"Push Notifications\".\n\n4.2\n Next Enable \"Background Modes\" and check \"Remote notifications\".\n\n\nIMAGE\n\n\n5. Add Required Code\n\n\nAdd following Kontext initialization code to your \nAppDelegate\n.\n\n\n\n\n\n\nSwift\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nimport\n \nKontext\n\n\n\nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]?)\n \n-\n \nBool\n \n{\n\n\n   \nlet\n \nkontextInitSettings\n \n=\n \n[\nkontextSettingsKeyAutoPrompt\n:\n \nfalse\n]\n\n\n   \n// Replace \nYOUR_APP_ID\n with your Kontext App ID.\n\n   \nKontext\n.\ninitWithLaunchOptions\n(\nlaunchOptions\n,\n\n       \nappId\n:\n \nYOUR_APP_ID\n,\n\n       \nhandleNotificationAction\n:\n \nnil\n,\n\n       \nsettings\n:\n \nkontextInitSettings\n)\n\n\n   \nKontext\n.\ninFocusDisplayType\n \n=\n \nKontextNotificationDisplayType\n.\nnotification\n;\n\n\n   \n// Recommend moving the below line to prompt for push after informing the user about\n\n   \n//   how your app will use them.\n\n   \nKontext\n.\npromptForPushNotifications\n(\nuserResponse\n:\n \n{\n \naccepted\n \nin\n\n      \nprint\n(\nUser accepted notifications: \n\\(\naccepted\n)\n)\n\n   \n})\n\n\n   \nreturn\n \ntrue\n\n\n}\n\n\n\n\n\n\n\n\nObjective-C\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n#import \nKontext/Kontext.h\n\n\n\n@implementation\n \nAppDelegate\n\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n \n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n \n{\n\n\n   \n// Replace \n11111111-2222-3333-4444-0123456789ab\n with your Kontext App ID.\n\n   \n[\nKontext\n \ninitWithLaunchOptions\n:\nlaunchOptions\n\n                              \nappId\n:\n@\n11111111-2222-3333-4444-0123456789ab\n\n                 \nhandleNotificationAction\n:\nnil\n\n                            \nsettings\n:\n@{\nkontextSettingsKeyAutoPrompt\n:\n \n@\nfalse\n}\n];\n\n   \nKontext\n.\ninFocusDisplayType\n \n=\n \nKontextNotificationDisplayTypeNotification\n;\n\n\n   \n// Recommend moving the below line to prompt for push after informing the user about\n\n   \n//   how your app will use them.\n\n   \n[\nKontext\n \npromptForPushNotificationsWithUserResponse\n:\n^\n(\nBOOL\n \naccepted\n)\n \n{\n\n        \nNSLog\n(\n@\nUser accepted notifications: %d\n,\n \naccepted\n);\n\n   \n}];\n\n\n   \nreturn\n \nYES\n;\n\n\n}\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nKontext \ninitWithLaunchOptions\n\u00a0must be called from your\u00a0\ndidFinishLaunchingWithOptions\n, as in the example above.\n\n\n\n\n\n\nTroubleshooting\n\n\nIf run into any issues please see our \niOS troubleshooting guide\n.\n\n\n\n\n6. Add Email\n\n\nRECOMMENDED\n\n\nNext, if you collect emails from users, you can set a user's email with the \nsetEmail\n method. This enables Kontext Email Messaging, which allows you to send emails in addition to push.\n\n\n\n\n\n\nSwift\n\n\n1\nKontext\n.\nsetEmail\n(\nexample@domain.com\n);\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n[\nKontext\n \nsetEmail\n:\n@\nexample@domain.com\n];\n\n\n\n\n\n\n\n\n7. Add App Groups (Optional but Recommended)\n\n\nIn order for your application to be able to let push notifications increment/decrement the badge count, you need to set up an\u00a0\nApp Group\n\u00a0for your application.\n\n\nCallbacks\n\n\nKontextHandleNotificationReceivedBlock\n - Called when a notification is received while your app is in focus only.\n\nKontextHandleNotificationActionBlock\n - This will be called when a notification is tapped on.\nSee our \ninitWithLaunchOptions\n documentation to add these.\n\n\n\n\nYou're Done!\n\n\nNext up: Send your first push notification via the \nKontext Dashboard", 
            "title": "iOS Quickstart"
        }, 
        {
            "location": "/iOS-quickstart/#ios-sdk-setup", 
            "text": "Upgrade to 2.5.1+  A number the methods and classes below were recently added in our 3.5.1 SDK. Make sure you have updated to this version.", 
            "title": "iOS SDK Setup"
        }, 
        {
            "location": "/iOS-quickstart/#required-for-setup", 
            "text": "A Kontext Account  if you do not already have one  Your Kontext App ID, available in  Keys   IDs  An iOS Push Certificate.  Generate one here .  An iOS device (iPhone, iPad, iPod Touch) to test on. The Xcode simulator doesn't support push notifications so you must test on a real device.  A Mac with a new version of Xcode", 
            "title": "Required For Setup"
        }, 
        {
            "location": "/iOS-quickstart/#1-download-the-sdk", 
            "text": "Click Here to download the SDK", 
            "title": "1. Download the SDK"
        }, 
        {
            "location": "/iOS-quickstart/#2-add-notification-service-extension", 
            "text": "2.1  In Xcode Select  File     New     Target...  2.2  Select  Notification Service Extension  then press  Next .", 
            "title": "2. Add Notification Service Extension"
        }, 
        {
            "location": "/iOS-quickstart/#image", 
            "text": "2.3 \u00a0Enter the product name as\u00a0 KontextNotificationServiceExtension \u00a0and press\u00a0 Finish .", 
            "title": "IMAGE"
        }, 
        {
            "location": "/iOS-quickstart/#image_1", 
            "text": "2.4 \u00a0Press Cancel on the Activate scheme prompt.", 
            "title": "IMAGE"
        }, 
        {
            "location": "/iOS-quickstart/#image_2", 
            "text": "By cancelling, you are keeping Xcode debugging your app, instead of just the extension. If you activate by accident, you can always switch back to debug your app within Xcode (next to the play button).  2.5  Open the Xcode project settings and select the KontextNotificationServiceExtension target. Unless you have a specific reason not to, you should set the  Deployment Target  to be iOS 10.", 
            "title": "IMAGE"
        }, 
        {
            "location": "/iOS-quickstart/#image_3", 
            "text": "2.6 \u00a0Open\u00a0 NotificationService.m \u00a0or\u00a0 NotificationService.swift \u00a0and replace the whole file contents with the below code.    Swift   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31 import   UserNotifications  import   Kontext  class   NotificationService :   UNNotificationServiceExtension   { \n\n     var   contentHandler :   (( UNNotificationContent )   -   Void )? \n     var   receivedRequest :   UNNotificationRequest ! \n     var   bestAttemptContent :   UNMutableNotificationContent ? \n\n     override   func   didReceive ( _   request :   UNNotificationRequest ,   withContentHandler   contentHandler :   @ escaping   ( UNNotificationContent )   -   Void )   { \n         self . receivedRequest   =   request ; \n         self . contentHandler   =   contentHandler \n         bestAttemptContent   =   ( request . content . mutableCopy ()   as ?   UNMutableNotificationContent ) \n\n         if   let   bestAttemptContent   =   bestAttemptContent   { \n             Kontext . didReceiveNotificationExtensionRequest ( self . receivedRequest ,   with :   self . bestAttemptContent ) \n             contentHandler ( bestAttemptContent ) \n         } \n     } \n\n     override   func   serviceExtensionTimeWillExpire ()   { \n         // Called just before the extension will be terminated by the system. \n         // Use this as an opportunity to deliver your  best attempt  at modified content, otherwise the original push payload will be used. \n         if   let   contentHandler   =   contentHandler ,   let   bestAttemptContent   =    bestAttemptContent   { \n             Kontext . serviceExtensionTimeWillExpireRequest ( self . receivedRequest ,   with :   self . bestAttemptContent ) \n             contentHandler ( bestAttemptContent ) \n         } \n     }  }     Objective-C   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40 #import  Kontext/Kontext.h  #import  NotificationService.h  @interface   NotificationService   ()  @property   ( nonatomic ,   strong )   void   ( ^ contentHandler )( UNNotificationContent   * contentToDeliver );  @property   ( nonatomic ,   strong )   UNNotificationRequest   * receivedRequest ;  @property   ( nonatomic ,   strong )   UNMutableNotificationContent   * bestAttemptContent ;  @end  @implementation   NotificationService  -   ( void ) didReceiveNotificationRequest: ( UNNotificationRequest   * ) request   withContentHandler: ( void   ( ^ )( UNNotificationContent   *   _Nonnull )) contentHandler   { \n     self . receivedRequest   =   request ; \n     self . contentHandler   =   contentHandler ; \n     self . bestAttemptContent   =   [ request . content   mutableCopy ]; \n\n     [ Kontext   didReceiveNotificationExtensionRequest : self . receivedRequest   withMutableNotificationContent : self . bestAttemptContent ]; \n\n     // DEBUGGING: Uncomment the 2 lines below and comment out the one above to ensure this extension is excuting \n     //            Note, this extension only runs when mutable-content is set \n     //            Setting an attachment or action buttons automatically adds this \n     // NSLog(@ Running NotificationServiceExtension ); \n     // self.bestAttemptContent.body = [@ [Modified]   stringByAppendingString:self.bestAttemptContent.body]; \n\n     self . contentHandler ( self . bestAttemptContent );  }  -   ( void ) serviceExtensionTimeWillExpire   { \n     // Called just before the extension will be terminated by the system. \n     // Use this as an opportunity to deliver your  best attempt  at modified content, otherwise the original push payload will be used. \n\n     [ Kontext   serviceExtensionTimeWillExpireRequest : self . receivedRequest   withMutableNotificationContent : self . bestAttemptContent ]; \n\n     self . contentHandler ( self . bestAttemptContent );  }  @end     Ignore any build errors at this point, step 2 will import Kontext which will resolve any errors.", 
            "title": "IMAGE"
        }, 
        {
            "location": "/iOS-quickstart/#3-import-kontext-into-your-xcode-project", 
            "text": "Setup CocoaPods  on your system if you don't have it already.   Make sure you have version  1.1.0  or newer by running  pod --version  from the terminal.  Run the following to upgrade  sudo gem install cocoapods   3.1  Make sure your current Xcode project is closed.  3.2  Run  pod init  from the terminal in your project directory.  3.3  Open the newly created  Podfile  with your favorite code editor such as Sublime.  3.4  Add  pod  Kontext ,  = 2.5.2 ,   3.0  in your project name target as well as  KontextNotificationServiceExtension .  1\n2\n3\n4\n5\n6\n7 target  project_name  do\n  pod  Kontext ,  = 2.6.2 ,   3.0 \nend\n\ntarget  KontextNotificationServiceExtension  do\n  pod  Kontext ,  = 2.6.2 ,   3.0 \nend   3.5 \u00a0Run the following from the terminal.  1\n2 pod repo update\npod install   3.6 \u00a0Open the newly created\u00a0 .xcworkspace \u00a0file.  Make sure to always open the workspace from now on.    3.7 \u00a0Continue to Steps 3 and 4 below", 
            "title": "3. Import Kontext into your Xcode project"
        }, 
        {
            "location": "/iOS-quickstart/#4-add-required-capabilities", 
            "text": "4.1  Select the root project and Under Capabilities Enable \"Push Notifications\". 4.2  Next Enable \"Background Modes\" and check \"Remote notifications\".", 
            "title": "4. Add Required Capabilities"
        }, 
        {
            "location": "/iOS-quickstart/#image_4", 
            "text": "", 
            "title": "IMAGE"
        }, 
        {
            "location": "/iOS-quickstart/#5-add-required-code", 
            "text": "Add following Kontext initialization code to your  AppDelegate .    Swift   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22 import   Kontext  func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ]?)   -   Bool   { \n\n    let   kontextInitSettings   =   [ kontextSettingsKeyAutoPrompt :   false ] \n\n    // Replace  YOUR_APP_ID  with your Kontext App ID. \n    Kontext . initWithLaunchOptions ( launchOptions , \n        appId :   YOUR_APP_ID , \n        handleNotificationAction :   nil , \n        settings :   kontextInitSettings ) \n\n    Kontext . inFocusDisplayType   =   KontextNotificationDisplayType . notification ; \n\n    // Recommend moving the below line to prompt for push after informing the user about \n    //   how your app will use them. \n    Kontext . promptForPushNotifications ( userResponse :   {   accepted   in \n       print ( User accepted notifications:  \\( accepted ) ) \n    }) \n\n    return   true  }     Objective-C   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 #import  Kontext/Kontext.h  @implementation   AppDelegate  -   ( BOOL ) application: ( UIApplication   * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions   { \n\n    // Replace  11111111-2222-3333-4444-0123456789ab  with your Kontext App ID. \n    [ Kontext   initWithLaunchOptions : launchOptions \n                               appId : @ 11111111-2222-3333-4444-0123456789ab \n                  handleNotificationAction : nil \n                             settings : @{ kontextSettingsKeyAutoPrompt :   @ false } ]; \n    Kontext . inFocusDisplayType   =   KontextNotificationDisplayTypeNotification ; \n\n    // Recommend moving the below line to prompt for push after informing the user about \n    //   how your app will use them. \n    [ Kontext   promptForPushNotificationsWithUserResponse : ^ ( BOOL   accepted )   { \n         NSLog ( @ User accepted notifications: %d ,   accepted ); \n    }]; \n\n    return   YES ;  }      Note  Kontext  initWithLaunchOptions \u00a0must be called from your\u00a0 didFinishLaunchingWithOptions , as in the example above.    Troubleshooting  If run into any issues please see our  iOS troubleshooting guide .", 
            "title": "5. Add Required Code"
        }, 
        {
            "location": "/iOS-quickstart/#6-add-email", 
            "text": "RECOMMENDED  Next, if you collect emails from users, you can set a user's email with the  setEmail  method. This enables Kontext Email Messaging, which allows you to send emails in addition to push.    Swift  1 Kontext . setEmail ( example@domain.com );     Objective-C  1 [ Kontext   setEmail : @ example@domain.com ];", 
            "title": "6. Add Email"
        }, 
        {
            "location": "/iOS-quickstart/#7-add-app-groups-optional-but-recommended", 
            "text": "In order for your application to be able to let push notifications increment/decrement the badge count, you need to set up an\u00a0 App Group \u00a0for your application.", 
            "title": "7. Add App Groups (Optional but Recommended)"
        }, 
        {
            "location": "/iOS-quickstart/#callbacks", 
            "text": "KontextHandleNotificationReceivedBlock  - Called when a notification is received while your app is in focus only. KontextHandleNotificationActionBlock  - This will be called when a notification is tapped on.\nSee our  initWithLaunchOptions  documentation to add these.   You're Done!  Next up: Send your first push notification via the  Kontext Dashboard", 
            "title": "Callbacks"
        }, 
        {
            "location": "/gdpr/", 
            "text": "GDPR Overview\n\n\n\n\nHave Suggestion?\n\n\nKindly drop us a line at \nsupport@kontext.in\n\n\n\n\nThe GDPR (General Data Protection Regulation) is set to take effect May 25, 2018, and its regulations apply to any company, person, or group that collects, processes, or otherwise handles the personal data of EU and UK residents.\n\n\nKontext, GDPR, and you\n\n\nThe GDPR defines two different types of organizations who have to follow the new regulations: data controllers and data processors.\n\n\n\n\nData controllers\n determine why and how personal data is processed. As a Kontext customer, your organization is considered a data controller.\n\n\nData processors\n process user data on behalf of the controller. Kontext processes user data on your behalf, which makes us a data processor.\n\n\n\n\nAs a processor, we provide the technical capabilities and organizational processes that will allow you, our customers, to maintain the rights of your EU and UK users while using our product.\n\n\nSee below for some common tasks to help you remain GDPR compliant while using Kontext. The information below is not legal advice. We recommend you work with a lawyer to understand exactly how GDPR applies to your organization.\n\n\nInforming your end users\n\n\nAs a data controller, you have to inform your end-users about the personal data you collect from them and their rights surrounding this data. The GDPR lays out several requirements for what you must inform your end-users, and it\u2019s up to you to provide the information in a transparent, accessible way.\n\n\nFor more details on how Kontext handles and protects your users\u2019 data, refer to the security information in your contract\u2019s data processing addendum.\n\n\nUser consent for data collection\n\n\nGDPR sets standards (such as consent or legitimate interest) for when it's lawful to process data. It's up to you, the controller, to ensure that all the data you send to Kontext is lawful. We recommend you work with legal counsel to determine which rationale for data processing applies to you.\n\n\nTo prevent data collection through Kontext, do not call Kontext.start() until after the user opts-in for data collection. You can also offer separate opt-out prompts for different messaging channels in Kontext. Giving users more options to control their app experience might encourage them to consent (opt-in) to data collection.\n\n\nFor example, if a user opts-in to data collection in general, but not to email or push, your app should call Kontext.logoutEmail and the opt-out methods for the push and email channels. \n\n\nBlock data collection and processing\n\n\nIf a user objects to data processing, you can prevent Kontext from collecting and processing data for that user with the \nlogout\n API request.\n\n\nlogout\n will stop Kontext from collecting data for that user moving forward. In order to ensure that Kontext does not process this user\u2019s old data, we will delete all of their data from our systems.\n\n\nFor more details, please see our \nlogout API documentation\n\n\nErasing user data\n\n\nUnder GDPR, data subjects have the right to request the deletion or removal of personal data.\n\n\nTo delete a user\u2019s data from Kontext, you can use the deleteUser request, which will delete all user profile information for that user. To also erase all historical data for the user, include the \nfullErasure\n flag and set it to \ntrue\n. See our API documentation for more on the deleteUser call.\n\n\n\n\nInfo\n\n\nIf you export Kontext data into your backup locations, then you are responsible for handling GDPR requests in that data.\n\n\n\n\nData access and portability\n\n\nUsers also have the right to request a copy of their personal data in a human or machine-readable format. The GDPR also specifies that data subjects can obtain and reuse their personal data for their own purposes (for example, to create an account with a competing service).\n\n\nRectify user data\n\n\nAs a data controller, you must give users the ability to correct personal data if they feel it is inaccurate or incomplete. In Kontext, this includes user location, user attributes, and device attributes.\n\n\nUse the \nsendUserAttributes\n API request to change a user's attributes or location data in Kontext. \n\n\nAdditional support\n\n\nIf you are unsure of how to use some of the methods or processes above, contact \nsupport@Kontext.in\n for assistance. We are happy to answer any questions on how to use our platform. Of course, please do not mistake this for legal advice. If you have legal questions about the GDPR, we urge you to consult with your lawyer.", 
            "title": "GDPR"
        }, 
        {
            "location": "/gdpr/#gdpr-overview", 
            "text": "Have Suggestion?  Kindly drop us a line at  support@kontext.in   The GDPR (General Data Protection Regulation) is set to take effect May 25, 2018, and its regulations apply to any company, person, or group that collects, processes, or otherwise handles the personal data of EU and UK residents.", 
            "title": "GDPR Overview"
        }, 
        {
            "location": "/gdpr/#kontext-gdpr-and-you", 
            "text": "The GDPR defines two different types of organizations who have to follow the new regulations: data controllers and data processors.   Data controllers  determine why and how personal data is processed. As a Kontext customer, your organization is considered a data controller.  Data processors  process user data on behalf of the controller. Kontext processes user data on your behalf, which makes us a data processor.   As a processor, we provide the technical capabilities and organizational processes that will allow you, our customers, to maintain the rights of your EU and UK users while using our product.  See below for some common tasks to help you remain GDPR compliant while using Kontext. The information below is not legal advice. We recommend you work with a lawyer to understand exactly how GDPR applies to your organization.", 
            "title": "Kontext, GDPR, and you"
        }, 
        {
            "location": "/gdpr/#informing-your-end-users", 
            "text": "As a data controller, you have to inform your end-users about the personal data you collect from them and their rights surrounding this data. The GDPR lays out several requirements for what you must inform your end-users, and it\u2019s up to you to provide the information in a transparent, accessible way.  For more details on how Kontext handles and protects your users\u2019 data, refer to the security information in your contract\u2019s data processing addendum.", 
            "title": "Informing your end users"
        }, 
        {
            "location": "/gdpr/#user-consent-for-data-collection", 
            "text": "GDPR sets standards (such as consent or legitimate interest) for when it's lawful to process data. It's up to you, the controller, to ensure that all the data you send to Kontext is lawful. We recommend you work with legal counsel to determine which rationale for data processing applies to you.  To prevent data collection through Kontext, do not call Kontext.start() until after the user opts-in for data collection. You can also offer separate opt-out prompts for different messaging channels in Kontext. Giving users more options to control their app experience might encourage them to consent (opt-in) to data collection.  For example, if a user opts-in to data collection in general, but not to email or push, your app should call Kontext.logoutEmail and the opt-out methods for the push and email channels.", 
            "title": "User consent for data collection"
        }, 
        {
            "location": "/gdpr/#block-data-collection-and-processing", 
            "text": "If a user objects to data processing, you can prevent Kontext from collecting and processing data for that user with the  logout  API request.  logout  will stop Kontext from collecting data for that user moving forward. In order to ensure that Kontext does not process this user\u2019s old data, we will delete all of their data from our systems.  For more details, please see our  logout API documentation", 
            "title": "Block data collection and processing"
        }, 
        {
            "location": "/gdpr/#erasing-user-data", 
            "text": "Under GDPR, data subjects have the right to request the deletion or removal of personal data.  To delete a user\u2019s data from Kontext, you can use the deleteUser request, which will delete all user profile information for that user. To also erase all historical data for the user, include the  fullErasure  flag and set it to  true . See our API documentation for more on the deleteUser call.   Info  If you export Kontext data into your backup locations, then you are responsible for handling GDPR requests in that data.", 
            "title": "Erasing user data"
        }, 
        {
            "location": "/gdpr/#data-access-and-portability", 
            "text": "Users also have the right to request a copy of their personal data in a human or machine-readable format. The GDPR also specifies that data subjects can obtain and reuse their personal data for their own purposes (for example, to create an account with a competing service).", 
            "title": "Data access and portability"
        }, 
        {
            "location": "/gdpr/#rectify-user-data", 
            "text": "As a data controller, you must give users the ability to correct personal data if they feel it is inaccurate or incomplete. In Kontext, this includes user location, user attributes, and device attributes.  Use the  sendUserAttributes  API request to change a user's attributes or location data in Kontext.", 
            "title": "Rectify user data"
        }, 
        {
            "location": "/gdpr/#additional-support", 
            "text": "If you are unsure of how to use some of the methods or processes above, contact  support@Kontext.in  for assistance. We are happy to answer any questions on how to use our platform. Of course, please do not mistake this for legal advice. If you have legal questions about the GDPR, we urge you to consult with your lawyer.", 
            "title": "Additional support"
        }, 
        {
            "location": "/data-security/", 
            "text": "Security Overview\n\n\nProtecting customer data is always a priority at Kontext. Our success as a business relies on the security of customer data stored with us. \n\n\nAs a company, we use the Kontext platform ourselves for user analytics and engagement. This document mentions steps we take to ensure security, privacy and confidentiality of customer data.\n\n\nInflight Incoming Data Security\n\n\nAll data collection endpoints support TLS 1.1 and TLS 1.2 encryption protocols with SHA256 with RSA signature algorithm. This allows devices with varied support to access our collection/incoming endpoints while providing the TLS 1.2 to devices that support it.\n\n\nWe maintain a small list of known URLs where we respond to HTTPS requests. All requests to unknown URLs, or requests that don\u2019t match our expected data format are logged and silently dropped.\n\n\nThe operation team reviews all dropped requests periodically.\n\n\nDashboard Data Security\n\n\nThe Dashboard and API endpoints support TLS 1.1 and TLS 1.2 encryption protocols with SHA256 with RSA signature algorithm. Outdated SSL protocols are not supported. We allow dashboard access through modern secure browsers. Developers are required to use updated libraries to access our API endpoints.\n\n\nIncoming Request Logging\n\n\nAll incoming requests are logged and stored on persistent storage for analysis and audit. Logs are purged periodically based on industry retention best practices.\n\n\nCustomer Data Security\n\n\nCustomer data is stored in an encoded format optimized for performance, rather than stored in a traditional file system or a database. Data is dispersed across a number of physical and logical volumes for redundancy and expedient access, thereby obfuscating it from tampering\n\n\nCustomers own all rights to their data and can choose to download it via an API or delete it from our systems. Kontext provides role based app\u00ad level access control to customers to manage access to their own data.\n\n\nKontext does not share or sell customer data.\n\n\nRunning Systems\n\n\nKontext uses battle tested open source software to power some parts of its application stack. We subscribe to CVE vulnerability data and patch critical vulnerabilities within 24 hours of publication. In addition, we destroy and rebuild nodes that power public facing endpoints every few days. This ensures we don\u2019t have configuration drift in production.\n\n\nData Center Security\n\n\nAzure Cloud is our hosting provider. They maintain data\u00adcenters that are fully compliant with a range of certifications which allow finance, healthcare and government data to be stored in their data\u00adcenters. A full list of compliance and more information along with certification is available at \nhttps://azure.microsoft.com/en-in/support/legal/subscription-agreement-nov-2014/\n.\n\n\nShared responsibility with Amazon means we focus on application and data security while physical security is managed by them.\n\n\nTeam\n\n\nAt Kontext, our engineering and IT teams are experienced and have a know-how of industry best practices on security. Before Kontext, we\u2019ve built and run many heavy traffic sites both on physical as well as virtual infrastructure. We bring many years of operational experience running secure and scalable services.\n\n\nThe security and confidentiality of your data is core to our success as a business and we will continue to be proactive, vigilant and diligent in ensuring its safety.\n\n\nContact Info\n\n\nIf you notice something unusual in your account, have a question or a suggestion please e-mail us at \nsupport@kontext.in\n.", 
            "title": "Security Overview"
        }, 
        {
            "location": "/data-security/#security-overview", 
            "text": "Protecting customer data is always a priority at Kontext. Our success as a business relies on the security of customer data stored with us.   As a company, we use the Kontext platform ourselves for user analytics and engagement. This document mentions steps we take to ensure security, privacy and confidentiality of customer data.", 
            "title": "Security Overview"
        }, 
        {
            "location": "/data-security/#inflight-incoming-data-security", 
            "text": "All data collection endpoints support TLS 1.1 and TLS 1.2 encryption protocols with SHA256 with RSA signature algorithm. This allows devices with varied support to access our collection/incoming endpoints while providing the TLS 1.2 to devices that support it.  We maintain a small list of known URLs where we respond to HTTPS requests. All requests to unknown URLs, or requests that don\u2019t match our expected data format are logged and silently dropped.  The operation team reviews all dropped requests periodically.", 
            "title": "Inflight Incoming Data Security"
        }, 
        {
            "location": "/data-security/#dashboard-data-security", 
            "text": "The Dashboard and API endpoints support TLS 1.1 and TLS 1.2 encryption protocols with SHA256 with RSA signature algorithm. Outdated SSL protocols are not supported. We allow dashboard access through modern secure browsers. Developers are required to use updated libraries to access our API endpoints.", 
            "title": "Dashboard Data Security"
        }, 
        {
            "location": "/data-security/#incoming-request-logging", 
            "text": "All incoming requests are logged and stored on persistent storage for analysis and audit. Logs are purged periodically based on industry retention best practices.", 
            "title": "Incoming Request Logging"
        }, 
        {
            "location": "/data-security/#customer-data-security", 
            "text": "Customer data is stored in an encoded format optimized for performance, rather than stored in a traditional file system or a database. Data is dispersed across a number of physical and logical volumes for redundancy and expedient access, thereby obfuscating it from tampering  Customers own all rights to their data and can choose to download it via an API or delete it from our systems. Kontext provides role based app\u00ad level access control to customers to manage access to their own data.  Kontext does not share or sell customer data.", 
            "title": "Customer Data Security"
        }, 
        {
            "location": "/data-security/#running-systems", 
            "text": "Kontext uses battle tested open source software to power some parts of its application stack. We subscribe to CVE vulnerability data and patch critical vulnerabilities within 24 hours of publication. In addition, we destroy and rebuild nodes that power public facing endpoints every few days. This ensures we don\u2019t have configuration drift in production.", 
            "title": "Running Systems"
        }, 
        {
            "location": "/data-security/#data-center-security", 
            "text": "Azure Cloud is our hosting provider. They maintain data\u00adcenters that are fully compliant with a range of certifications which allow finance, healthcare and government data to be stored in their data\u00adcenters. A full list of compliance and more information along with certification is available at  https://azure.microsoft.com/en-in/support/legal/subscription-agreement-nov-2014/ .  Shared responsibility with Amazon means we focus on application and data security while physical security is managed by them.", 
            "title": "Data Center Security"
        }, 
        {
            "location": "/data-security/#team", 
            "text": "At Kontext, our engineering and IT teams are experienced and have a know-how of industry best practices on security. Before Kontext, we\u2019ve built and run many heavy traffic sites both on physical as well as virtual infrastructure. We bring many years of operational experience running secure and scalable services.  The security and confidentiality of your data is core to our success as a business and we will continue to be proactive, vigilant and diligent in ensuring its safety.", 
            "title": "Team"
        }, 
        {
            "location": "/data-security/#contact-info", 
            "text": "If you notice something unusual in your account, have a question or a suggestion please e-mail us at  support@kontext.in .", 
            "title": "Contact Info"
        }, 
        {
            "location": "/android/quickstart/", 
            "text": "Android SDK Setup\n\n\n\n\nUpgrade to 3.5.1+\n\n\nA number the methods and classes below were recently added in our 3.5.1 SDK. Make sure you have updated to this version.\n\n\n\n\nRequired For Setup\n\n\n\n\nA Kontext Account\n, if you do not already have one\n\n\nYour Kontext App ID, available in \nKeys \n IDs\n\n\nA Google/Firebase Server API Key\n\n\nA device or emulator that has Google Play services installed and updated on it\n\n\nAndroid Studio 2.3.3 or newer\n\n\n\n\n1. Download the SDK\n\n\nClick Here to download the SDK\n\n\n2. Gradle Setup\n\n\n2.1\n Place Kontext SDK in your app's \nlibs\n folder.\n\n\n2.2\n Add the following to your \ndependencies\n section.\n\n\n\n\nbuild.gradle\n\n\n\n\n1\n2\n3\n4\n5\ndependencies {\n    implementation(name:\nkontextSdk\n, ext:\naar\n)\n    implementation \ncom.google.android.gms:play-services-nearby:12.0.1\n\n    implementation \ncom.android.installreferrer:installreferrer:1.0\n\n}\n\n\n\n\n\n\n\n\nPlay Services Version\n\n\n\n\n1\nIn order to get access to all Kontext SDK features update all your app play services version to 12.0.1 or above.\n\n\n\n\n\n\n2.3\n Add the following in your \nandroid\n \n \ndefaultConfig\n section.\n\n\n\n\nUpdate \nPUT YOUR KONTEXT APP ID HERE\n with your Kontext app id\n\n\nbuild.gradle\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nandroid {\n   defaultConfig {\n      manifestPlaceholders = [\n          kontext_app_id: \nPUT YOUR KONTEXT APP ID HERE\n,\n          // Project number pulled from dashboard, local value is ignored.\n          kontext_google_project_number: \nREMOTE\n\n      ]\n    }\n }\n\n\n\n\n\n\n2.4\n Add the following in your \nApp Manifest application\n tag to enable Kontext In-App messaging.\n\n\n1\n2\n3\n4\n5\n6\napplication\n\n    \nactivity\n\n    \nandroid:name=\ncom.kontext.InAppMessageActivity\n\n    \nandroid:configChanges=\norientation|keyboardHidden\n\n    \nandroid:theme=\n@android:style/Theme.Translucent.NoTitleBar\n \n/\n\n\n/application\n\n\n\n\n\n\n\nSync Gradle\n\n\nMake sure to press \"Sync Now\" on the banner that pops up after saving!\n\n\n3. Add Required Code\n\n\n3.1\n Add the following to the \nonCreate\n method in your \nApplication\n class.\n\n\n\n\nDon't have an Application class? Follow our creation guide!\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nimport\n \ncom.kontext.Kontext\n;\n\n\n\npublic\n \nclass\n \nYourAppClass\n \nextends\n \nApplication\n \n{\n\n   \n@Override\n\n   \npublic\n \nvoid\n \nonCreate\n()\n \n{\n\n      \nsuper\n.\nonCreate\n();\n\n\n      \n// Kontext Initialization\n\n      \nKontext\n.\nstartInit\n(\nthis\n)\n\n        \n.\ninFocusDisplaying\n(\nKontext\n.\nOSInFocusDisplayOption\n.\nNotification\n)\n\n        \n.\nunsubscribeWhenNotificationsAreDisabled\n(\ntrue\n)\n\n        \n.\ninit\n();\n\n   \n}\n\n\n}\n\n\n\n\n\n\n\n4. Create a custom default notification icon\n\n\n4.1\n By default, notifications will be shown with a bell icon in the notification shade. \n\n\n\n\nTroubleshooting\n\n\n\n\n1\nIf run into any issues please see our [Android troubleshooting guide](/android/troubleshoot), or our general Troubleshooting section.\n\n\n\n\n\n\n5. Add Information to a User Profile\n\n\nRECOMMENDED\n\n\nA User Profile is automatically created in Kontext for each user launching your application.\n\n\nInitially, the User Profile starts out as anonymous, which means the profile does not contain any identifiable information about the user. You can enrich the profile with pre-defined attributes from the Kontext data model, such as name and email. You can also add custom attributes that you define to extend the Kontext data model.\n\n\nSending user profile information to Kontext using our Android SDK requires two steps. First, you have to build a JSON Object with the profile properties. Second, you have to call the SDK's \nsendUserAttributes\n) method and pass the object you created as a parameter.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nJSONObject\n \nuserProfile\n \n=\n \nnew\n \nJSONObject\n();\n\n      \ntry\n \n{\n\n         \nuserProfile\n.\nput\n(\nName\n,\n \nJhon Doe\n);\n\n         \nuserProfile\n.\nput\n(\nEmail\n,\n \njack@gmail.com\n);\n\n         \nuserProfile\n.\nput\n(\nPhone\n,\n \n+14155551234\n);\n\n         \nuserProfile\n.\nput\n(\nGender\n,\n \nM\n);\n\n         \nuserProfile\n.\nput\n(\nEmployed\n,\n \nY\n);\n\n         \nuserProfile\n.\nput\n(\nEducation\n,\n \nGraduate\n);\n\n         \nuserProfile\n.\nput\n(\nMarried\n,\nY\n);\n\n         \nuserProfile\n.\nput\n(\nAge\n,\n \n50\n);\n\n         \nuserProfile\n.\nput\n(\nTz\n,\n \nAsia/Kolkata\n);\n\n         \nKontext\n.\nsetUserAttributes\n(\nuserProfile\n);\n\n      \n}\n \ncatch\n \n(\nJSONException\n \ne\n)\n \n{\n\n         \ne\n.\nprintStackTrace\n();\n\n      \n}\n\n\n\n\n\n\n\n6. Track Screen Activity\n\n\nRECOMMENDED\n\n\nOnce you integrate the Kontext SDK, we automatically start tracking events, such as App Launch and Notification Viewed. Kontext SDK offers screen tracking API to track screen activity of a user.\n\n\nTo send screen activity to Kontext, you will have to call the \nsendScreen\n method with the name of the screen.\n\n\n1\nKontext\n.\nsendScreen\n(\nScreen Name\n);\n\n\n\n\n\n\n\n7. Track Custom Events\n\n\nRECOMMENDED\n\n\nOnce you integrate the Kontext SDK, we automatically start tracking events, such as App Launch and Notification Viewed. In addition, you can also track custom events.\n\n\nTo send screen activity to Kontext, you will have to call the \nsendEvent\n method with the name of the custom event you want to track.\n\n\n1\nKontext\n.\nsendEvent\n(\nProduct Added\n,\n \nApplie iPhone\n);\n\n\n\n\n\n\n\n\n\nYou're Done!\n\n\nNext up: Send your first push notification via the \nKontext Dashboard", 
            "title": "Quick Start"
        }, 
        {
            "location": "/android/quickstart/#android-sdk-setup", 
            "text": "Upgrade to 3.5.1+  A number the methods and classes below were recently added in our 3.5.1 SDK. Make sure you have updated to this version.", 
            "title": "Android SDK Setup"
        }, 
        {
            "location": "/android/quickstart/#required-for-setup", 
            "text": "A Kontext Account , if you do not already have one  Your Kontext App ID, available in  Keys   IDs  A Google/Firebase Server API Key  A device or emulator that has Google Play services installed and updated on it  Android Studio 2.3.3 or newer", 
            "title": "Required For Setup"
        }, 
        {
            "location": "/android/quickstart/#1-download-the-sdk", 
            "text": "Click Here to download the SDK", 
            "title": "1. Download the SDK"
        }, 
        {
            "location": "/android/quickstart/#2-gradle-setup", 
            "text": "2.1  Place Kontext SDK in your app's  libs  folder.  2.2  Add the following to your  dependencies  section.   build.gradle   1\n2\n3\n4\n5 dependencies {\n    implementation(name: kontextSdk , ext: aar )\n    implementation  com.google.android.gms:play-services-nearby:12.0.1 \n    implementation  com.android.installreferrer:installreferrer:1.0 \n}    Play Services Version   1 In order to get access to all Kontext SDK features update all your app play services version to 12.0.1 or above.   2.3  Add the following in your  android     defaultConfig  section.   Update  PUT YOUR KONTEXT APP ID HERE  with your Kontext app id  build.gradle   1\n2\n3\n4\n5\n6\n7\n8\n9 android {\n   defaultConfig {\n      manifestPlaceholders = [\n          kontext_app_id:  PUT YOUR KONTEXT APP ID HERE ,\n          // Project number pulled from dashboard, local value is ignored.\n          kontext_google_project_number:  REMOTE \n      ]\n    }\n }   2.4  Add the following in your  App Manifest application  tag to enable Kontext In-App messaging.  1\n2\n3\n4\n5\n6 application \n     activity \n     android:name= com.kontext.InAppMessageActivity \n     android:configChanges= orientation|keyboardHidden \n     android:theme= @android:style/Theme.Translucent.NoTitleBar   /  /application", 
            "title": "2. Gradle Setup"
        }, 
        {
            "location": "/android/quickstart/#sync-gradle", 
            "text": "Make sure to press \"Sync Now\" on the banner that pops up after saving!", 
            "title": "Sync Gradle"
        }, 
        {
            "location": "/android/quickstart/#3-add-required-code", 
            "text": "3.1  Add the following to the  onCreate  method in your  Application  class.   Don't have an Application class? Follow our creation guide!    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 import   com.kontext.Kontext ;  public   class   YourAppClass   extends   Application   { \n    @Override \n    public   void   onCreate ()   { \n       super . onCreate (); \n\n       // Kontext Initialization \n       Kontext . startInit ( this ) \n         . inFocusDisplaying ( Kontext . OSInFocusDisplayOption . Notification ) \n         . unsubscribeWhenNotificationsAreDisabled ( true ) \n         . init (); \n    }  }", 
            "title": "3. Add Required Code"
        }, 
        {
            "location": "/android/quickstart/#4-create-a-custom-default-notification-icon", 
            "text": "4.1  By default, notifications will be shown with a bell icon in the notification shade.    Troubleshooting   1 If run into any issues please see our [Android troubleshooting guide](/android/troubleshoot), or our general Troubleshooting section.", 
            "title": "4. Create a custom default notification icon"
        }, 
        {
            "location": "/android/quickstart/#5-add-information-to-a-user-profile", 
            "text": "RECOMMENDED  A User Profile is automatically created in Kontext for each user launching your application.  Initially, the User Profile starts out as anonymous, which means the profile does not contain any identifiable information about the user. You can enrich the profile with pre-defined attributes from the Kontext data model, such as name and email. You can also add custom attributes that you define to extend the Kontext data model.  Sending user profile information to Kontext using our Android SDK requires two steps. First, you have to build a JSON Object with the profile properties. Second, you have to call the SDK's  sendUserAttributes ) method and pass the object you created as a parameter.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 JSONObject   userProfile   =   new   JSONObject (); \n       try   { \n          userProfile . put ( Name ,   Jhon Doe ); \n          userProfile . put ( Email ,   jack@gmail.com ); \n          userProfile . put ( Phone ,   +14155551234 ); \n          userProfile . put ( Gender ,   M ); \n          userProfile . put ( Employed ,   Y ); \n          userProfile . put ( Education ,   Graduate ); \n          userProfile . put ( Married , Y ); \n          userProfile . put ( Age ,   50 ); \n          userProfile . put ( Tz ,   Asia/Kolkata ); \n          Kontext . setUserAttributes ( userProfile ); \n       }   catch   ( JSONException   e )   { \n          e . printStackTrace (); \n       }", 
            "title": "5. Add Information to a User Profile"
        }, 
        {
            "location": "/android/quickstart/#6-track-screen-activity", 
            "text": "RECOMMENDED  Once you integrate the Kontext SDK, we automatically start tracking events, such as App Launch and Notification Viewed. Kontext SDK offers screen tracking API to track screen activity of a user.  To send screen activity to Kontext, you will have to call the  sendScreen  method with the name of the screen.  1 Kontext . sendScreen ( Screen Name );", 
            "title": "6. Track Screen Activity"
        }, 
        {
            "location": "/android/quickstart/#7-track-custom-events", 
            "text": "RECOMMENDED  Once you integrate the Kontext SDK, we automatically start tracking events, such as App Launch and Notification Viewed. In addition, you can also track custom events.  To send screen activity to Kontext, you will have to call the  sendEvent  method with the name of the custom event you want to track.  1 Kontext . sendEvent ( Product Added ,   Applie iPhone );     You're Done!  Next up: Send your first push notification via the  Kontext Dashboard", 
            "title": "7. Track Custom Events"
        }, 
        {
            "location": "/android/reference/", 
            "text": "Android Native SDK\n\n\nKontext ANDROID Native API Reference\n\n\n\n\nJust starting with Android?\n\n\nCheck out our\u00a0\nAndroid SDK Setup\n guide.\n\n\n\n\n\n\nUpgrade to 3.5.1+\n\n\nA number the methods and classes below were recently added in our 3.5.1 SDK. Make sure you have updated to this version.\n\n\n\n\n\n\n\n\n\n\nCalls\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nInitialization\n\n\n\n\n\n\n\n\n\n\ninit\n\n\nBuilder Method\n\n\nInitialize Kontext\n\n\n\n\n\n\nstartInit\n\n\nBuilder Method\n\n\n\n\n\n\n\n\nsetNotificationReceivedHandler\n\n\nBuilder Method\n\n\n\n\n\n\n\n\nsetNotificationOpenedHandler\n\n\nBuilder Method\n\n\n\n\n\n\n\n\nautoPromptLocation\n\n\nBuilder Method\n\n\nAutomatically Prompt Users for Location\n\n\n\n\n\n\ndisableGmsMissingPrompt\n\n\nBuilder Method\n\n\nAutomatically Prompt User to update Google Play if out of date\n\n\n\n\n\n\nunsubscribeWhenNotificationsAreDisabled\n\n\nBuilder Method\n\n\nIf notifications are disabled for your app unsubscribe them from Kontext.\n\n\n\n\n\n\nfilterOtherGCMReceivers\n\n\nBuilder Method\n\n\nEnable to prevent other broadcast receivers from receiving Kontext FCM / GCM payloads.\n\n\n\n\n\n\nsetInFocusDisplaying\n\n\nMethod\n\n\nChange how the notification is displayed when your app is actively being used.\n\n\n\n\n\n\nPrivacy\n\n\n\n\n\n\n\n\n\n\nsetRequiresUserPrivacyConsent\n\n\nMethod\n\n\nDelays initialization of the SDK until the user provides privacy consent\n\n\n\n\n\n\nprovideUserConsent\n\n\nMethod\n\n\nTells the SDK that the user has provided privacy consent (if required)\n\n\n\n\n\n\nuserProvidedPrivacyConsent\n\n\nMethod\n\n\nReturns a boolean indicating if the SDK is waiting for user privacy consent\n\n\n\n\n\n\nStauts\n\n\n\n\n\n\n\n\n\n\ngetPermissionSubscriptionState\n\n\nMethod\n\n\nCurrent Permission and Subscription status\n\n\n\n\n\n\naddPermissionObserver\n\n\nMethod\n\n\nPermission status changes\n\n\n\n\n\n\naddSubscriptionObserver\n\n\nMethod\n\n\nSubscription status changes\n\n\n\n\n\n\nEvents\n\n\n\n\n\n\n\n\n\n\nsendEvent\n\n\nMethod\n\n\nSend a single user event to Kontext\n\n\n\n\n\n\nsendEvents\n\n\nMethod\n\n\nBatch and send multiple events to Kontext\n\n\n\n\n\n\nsendScreen\n\n\nMethod\n\n\nSend screen view activity to Kontext\n\n\n\n\n\n\nsendUserAttributes\n\n\nMethod\n\n\nSend user properties to Kontext\n\n\n\n\n\n\nData\n\n\n\n\n\n\n\n\n\n\npromptLocation\n\n\nMethod\n\n\nPrompt Users for Location\n\n\n\n\n\n\nsetLocationShared\n\n\nMethod\n\n\nDisable or enable location collection (Defaults to enabled) if your app has location permission\n\n\n\n\n\n\nReceiving Notifications\n\n\n\n\n\n\n\n\n\n\npostNotification\n\n\nMethod\n\n\nSend or schedule a notification to a user\n\n\n\n\n\n\ncancelNotification\n\n\nMethod\n\n\nDelete a single app notification\n\n\n\n\n\n\nclearKontextNotifications\n\n\nMethod\n\n\nDelete all app notifications\n\n\n\n\n\n\nsetSubscription\n\n\nMethod\n\n\nOpt users in or out of receiving notifications\n\n\n\n\n\n\nNotificationExtenderService\n\n\nMethod + Manifest\n\n\nAdd custom data to a notification, or override notification options\n\n\n\n\n\n\nEmail\n\n\n\n\n\n\n\n\n\n\nsetEmail\n\n\nMethod\n\n\nSet user's email\n\n\n\n\n\n\nlogoutEmail\n\n\nMethod\n\n\nLog user out to dissociate email from device\n\n\n\n\n\n\naddEmailSubscriptionObserver\n\n\nMethod\n\n\nObserver for subscription changes to email\n\n\n\n\n\n\nNotification Events\n\n\n\n\n\n\n\n\n\n\nNotificationReceivedHandler\n\n\nHandler\n\n\nWhen a notification is received by a device\n\n\n\n\n\n\nNotificationOpenedHandler\n\n\nHandler\n\n\nWhen a user takes an action on a notification\n\n\n\n\n\n\nOpened Action\n\n\nAndroid Manifes\n\n\nDisable resuming launcher activity when notification is opened\n\n\n\n\n\n\nObjects\n\n\n\n\n\n\n\n\n\n\nOSNotificationOpenResult\n\n\nObject\n\n\nInformation returned from a notification the user received\n\n\n\n\n\n\nOSNotification\n\n\nObject\n\n\nNotification the user received\n\n\n\n\n\n\nOSNotificationAction\n\n\n\n\nAction the user took on the notification\n\n\n\n\n\n\nOSNotificationPayload\n\n\n\n\nContents and settings of the notification the user received\n\n\n\n\n\n\nAppearance\n\n\n\n\n\n\n\n\n\n\nsetInFocusDisplaying\n\n\nMethod\n\n\nChange how the notification is displayed when your app is actively being used.\n\n\n\n\n\n\nenableVibrate\n\n\nMethod\n\n\nWhen user receives notification, vibrate device less\n\n\n\n\n\n\nenableSound\n\n\nMethod\n\n\nWhen user receives notification, do not play a sound\n\n\n\n\n\n\nDisable Badges\n\n\nAndroid Manifest\n\n\nDisable badge counts in your app\n\n\n\n\n\n\nDebug\n\n\n\n\n\n\n\n\n\n\nsetLogLevel\n\n\nMethod\n\n\nEnable logging to help debug Kontext implementation\n\n\n\n\n\n\n\n\nInitialization\n\n\ninit\n\n\nBUILDER METHOD\n\n\nInitializes Kontext to register the device for push notifications. Should be called in the \nonCreate\n method of your Application class.\n\n\n1\nKontext\n.\nstartInit\n(\nthis\n).\ninit\n();\n\n\n\n\n\n\n\nstartInit\n\n\nMETHOD\n\n\nInitializes Kontext to register the device for push notifications. Should be call in the \nonCreate\n of your Application class.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncontext\n\n\nContext\n\n\nYour Application Kontext.\n\n\n\n\n\n\n\n\nReturns\n\n\nKontext.Builder\n - See below for a list of methods available.\n\n\n1\n2\n3\n4\n5\n6\n7\npublic\n \nclass\n \nYourAppClass\n \nextends\n \nApplication\n \n{\n\n   \n@Override\n\n   \npublic\n \nvoid\n \nonCreate\n()\n \n{\n\n      \nsuper\n.\nonCreate\n();\n\n      \nKontext\n.\nstartInit\n(\nthis\n).\ninit\n();\n\n   \n}\n\n\n}\n\n\n\n\n\n\n\nautoPromptLocation\n\n\nBUILDER METHOD\n\n\nPrompts the user for location permissions. This allows for geotagging so you can send notifications to users based on location. See \npromptLocation\n for more details.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprompt\n\n\nboolean\n\n\nfalse\n  (DEFAULT) - do not prompt\ntrue\n  -  prompt users for location permissions when your app starts.\n\n\n\n\n\n\n\n\n1\n2\n3\nKontext\n.\nstartInit\n(\nthis\n)\n\n  \n.\nautoPromptLocation\n(\ntrue\n)\n\n  \n.\ninit\n();\n\n\n\n\n\n\n\nsetNotificationReceivedHandler\n\n\nBUILDER METHOD\n\n\nSets a notification received handler that will fire when a notification is received. It will be fired when your app is in focus or in the background.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nhandler\n\n\nNotificationReceivedHandler\n\n\nInstance to a class implementing this interference.\n\n\n\n\n\n\n\n\n1\n2\n3\nKontext\n.\nstartInit\n(\nthis\n)\n   \n   \n.\nsetNotificationReceivedHandler\n(\nnew\n \nExampleNotificationReceivedHandler\n())\n\n   \n.\ninit\n();\n\n\n\n\n\n\n\nsetNotificationOpenedHandler\n\n\nBUILDER METHOD\n\n\nSets a notification opened handler. The instance will be called when a notification is tapped on from the notification shade or when closing an Alert notification shown in the app.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nhndler\n\n\nNotificationOpenedHandler\n\n\nInstance to a class implementing this interference.\n\n\n\n\n\n\n\n\n1\n2\n3\nKontext\n.\nstartInit\n(\nthis\n)\n   \n   \n.\nsetNotificationOpenedHandler\n(\nnew\n \nExampleNotificationOpenedHandler\n())\n\n   \n.\ninit\n();\n\n\n\n\n\n\n\nsetInFocusDisplaying\n\n\nMETHOD\n\n\nSetting to control how Kontext notifications will be shown when one is received while your app is in focus.\n\n\nNotification\n - native notification display while user has app in focus (can be distracting).\n\nInAppAlert\n (DEFAULT) - native alert dialog display, which can be helpful during development.\n\nNone\n - notification is silent.\n\n\n1\nKontext\n.\nsetInFocusDisplaying\n(\nKontext\n.\nOSInFocusDisplayOption\n.\nNotification\n);\n\n\n\n\n\n\n\nPrivacy\n\n\nsetRequiresUserPrivacyConsent\n\n\nMETHOD\n\n\nLets your app require the user's privacy consent before it will initialize. If you call this method and pass in \ntrue\n, the SDK will delay initialization until your application calls `provideUserConsent(true).\n\n\nIf the SDK is waiting for the user's consent, calling any Kontext SDK methods will do nothing but print a warning. The user will not be registered for push notifications until this happens.\n\n\n1\n2\n// the SDK will delay initialization and won\nt collect data.\n\n\nKontext\n.\nsetRequiresUserPrivacyConsent\n(\ntrue\n);\n\n\n\n\n\n\n\nprovideUserConsent\n\n\nIf your application is set to require the user's privacy consent, you can provide this consent using this method. Until you call \nprovideUserConsent(true)\n, the SDK will not fully initialize and will not send any data to Kontext.\n\n\n1\n2\n3\n4\npublic\n \nvoid\n \nonUserTappedProvidePrivacyConsent\n(\nView\n \nv\n)\n \n{\n\n  \n//will initialize the Kontext SDK and enable push notifications\n\n  \nKontext\n.\nprovideUserConsent\n(\ntrue\n);\n\n\n}\n\n\n\n\n\n\n\nuserProvidedPrivacyConsent\n\n\nMETHOD\n\n\nReturns a boolean indicating if the user has provided privacy consent. \n\n\ndisableGmsMissingPrompt\n\n\nBUILDER METHOD\n\n\nPrompts the user to update/enable Google Play services if it's disabled on the device.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprompt\n\n\nboolean\n\n\nfalse\n (DEFAULT) - prompt users\n \ntrue\n\u00a0to never show the out of date prompt.\n\n\n\n\n\n\n\n\n1\n2\n3\nKontext\n.\nstartInit\n(\nthis\n)\n\n  \n.\ndisableGmsMissingPrompt\n(\ntrue\n)\n\n  \n.\ninit\n();\n\n\n\n\n\n\n\nunsubscribeWhenNotificationsAreDisabled\n\n\nBUILDER METHOD\n\n\nIf notifications are disabled for your app, unsubscribe the user from Kontext. This will happen when your users go to Settings \n Apps and turn off notifications, or if they long press one of your notifications and select \"block notifications\".\nThis is \nfalse\n by default.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprompt\n\n\nboolean\n\n\nfalse\n (DEFAULT) - prompt users\n \ntrue\n\u00a0to never show the out of date prompt.\n\n\n\n\n\n\n\n\n1\n2\n3\nKontext\n.\nstartInit\n(\nthis\n)\n\n  \n.\ndisableGmsMissingPrompt\n(\ntrue\n)\n\n  \n.\ninit\n();\n\n\n\n\n\n\n\nunsubscribeWhenNotificationsAreDisabled\n\n\nBUILDER METHOD\n\n\nIf notifications are disabled for your app, unsubscribe the user from Kontext. This will happen when your users go to Settings \n Apps and turn off notifications, or if they long press one of your notifications and select \"block notifications\".\nThis is \nfalse\n by default.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprompt\n\n\nboolean\n\n\nfalse\n\u00a0(DEFAULT) - don't unsubscribe users\n \ntrue\n\u00a0- unsubscribe users when notifications are disabled\n\n\n\n\n\n\n\n\n1\n2\n3\nKontext\n.\nstartInit\n(\nthis\n)\n\n  \n.\nunsubscribeWhenNotificationsAreDisabled\n(\ntrue\n)\n\n  \n.\ninit\n();\n\n\n\n\n\n\n\nStatus methods\n\n\nThe following methods provide details on the permission and subscribed state of the device. Use \ngetPermissionSubscriptionState\n to get the current immediate state and use \naddPermissionObserver\n and / or \naddSubscriptionObserver\n to react to changes.\n\n\nStatus Recommendations\n\n\ngetPermissionSubscriptionState\n - Use to load your UI to the correct state. Such as showing a toggle button to enable notifications.\n\n\naddSubscriptionObserver\n - Use to update your server when the user becomes subscribed or unsubscribed and to get the Kontext player / user id.\nExample if you need to store the Kontext player / user id on your backend you can make a REST API call directly from the observer's callback. The Kontext observer ONLY fires when there is a change, including NOT firing even if the app has been restarted. This helps ensure your not making unnecessary network calls to your backend on each app restart if nothing changed.\n\n\ngetPermissionSubscriptionState\n\n\nMETHOD\n\n\nGet the current notification and permission state. Returns a \nOSPermissionSubscriptionState\n type described below.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetPermissionStatus()\n\n\nOSPermissionState\n\n\nAndroid Notification Permissions state\n\n\n\n\n\n\ngetSubscriptionStatus()\n\n\nOSSubscriptionState\n\n\nGoogle and  Kontext subscription state\n\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\nOSPermissionSubscriptionState\n \nstatus\n \n=\n \nKontext\n.\ngetPermissionSubscriptionState\n();\n\n\nstatus\n.\ngetPermissionStatus\n().\ngetEnabled\n();\n\n\n\nstatus\n.\ngetSubscriptionStatus\n().\ngetSubscribed\n();\n\n\nstatus\n.\ngetSubscriptionStatus\n().\ngetUserSubscriptionSetting\n();\n\n\nstatus\n.\ngetSubscriptionStatus\n().\ngetUserId\n();\n\n\nstatus\n.\ngetSubscriptionStatus\n().\ngetPushToken\n();\n\n\n\n\n\n\n\nOSPermissionState\n\n\nCLASS\n\n\nThe Notification permission status of your app. Contains enabled value to know if the user has turned off notifications for your app.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetEnabled()\n\n\nboolean\n\n\ntrue\n\u00a0if notifications are enabled.\n Will only be\u00a0\nfalse\n\u00a0if the user disables notifications for your app from the system settings\n\n\n\n\n\n\n\n\nOSSubscriptionState\n\n\nCLASS\n\n\nProvides subscription state details of subscribed to push as well as the Kontext player / user id and the devices push token.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetSubscribed()\n\n\nboolean\n\n\ntrue\n\u00a0if the device can receive push notifications from  Kontext.\n \nfalse\n\u00a0if the device has disabled push notifications or not successfully registered yet with either  Kontext or FCM with a valid push token.\n\n\n\n\n\n\ngetUserId()\n\n\nString\n\n\nThe  Kontext player / user id for the device. \nnull\n\u00a0if the device hasn't registered with  Kontext's server yet.\n\n\n\n\n\n\ngetPushToken()\n\n\nString\n\n\nThe GCM / FCM push token for the device. \nnull\n\u00a0if the device hasn't registered with Google's server yet.\n\n\n\n\n\n\n\n\naddPermissionObserver\n\n\nHANDLER\n\n\nThe \nonOSPermissionChanged\n method will be fired on the passed-in object when a notification permission setting changes. This happens when the user enables or disables notifications for your app from the system settings outside of your app. Disable detection is supported on Android 4.4+.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\npublic\n \nclass\n \nMainActivity\n \nextends\n \nActivity\n \nimplements\n \nOSPermissionObserver\n \n{\n\n  \nprotected\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n \n{\n\n    \nKontext\n.\naddPermissionObserver\n(\nthis\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nonOSPermissionChanged\n(\nOSPermissionStateChanges\n \nstateChanges\n)\n \n{\n\n    \nif\n \n(\nstateChanges\n.\ngetFrom\n().\ngetEnabled\n()\n \n\n        \n!\nstateChanges\n.\ngetTo\n().\ngetEnabled\n())\n \n{\n\n         \nnew\n \nAlertDialog\n.\nBuilder\n(\nthis\n)\n\n             \n.\nsetMessage\n(\nNotifications Disabled!\n)\n\n             \n.\nshow\n();\n\n      \n}\n\n\n      \nLog\n.\ni\n(\nDebug\n,\n \nonOSPermissionChanged: \n \n+\n \nstateChanges\n);\n\n  \n}\n\n\n}\n\n\n\n// Example Logcat entry - User disabling notifications then returning to your app.\n\n\n// onOSPermissionChanged{\nfrom\n:{\nenabled\n:true},\nto\n:{\nenabled\n:false}}\n\n\n\n\n\n\n\n\n\nKeep a Reference\n\n\nMake sure to hold a reference to your observable at the class level, otherwise it my not fire.\n\n\n\n\n\n\nLeak Safe\n\n\nKontext holds a weak reference to your observer so it's guaranteed not to leak your \nActivity\n.\n\n\n\n\nOSPermissionStateChanges\n\n\nCLASS\n\n\nInstance is given to your \nonOSPermissionChanged\n method which provides what the value was (\n\"from\"\n) and what the value is now (\n\"to\"\n).\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetFrom()\n\n\nOSSubscriptionState\n\n\nWhat the state was\n\n\n\n\n\n\ngetTo()\n\n\nOSSubscriptionState\n\n\nWhat the state is now\n\n\n\n\n\n\n\n\naddSubscriptionObserver\n\n\nMETHOD\n\n\nThe \nonOSSubscriptionChanged\n method will be fired on the passed-in object when a notification subscription property changes.\n\n\nThis includes the following events:\n\n\n\n\nGetting a Registration Id (push token) from Google\n\n\nGetting a player / user id from Kontext\n\n\nKontext.setSubscription\n is called\n\n\nUser disables or enables notifications\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\npublic\n \nclass\n \nMainActivity\n \nextends\n \nActivity\n \nimplements\n \nOSSubscriptionObserver\n \n{\n\n  \nprotected\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n \n{\n\n    \nKontext\n.\naddSubscriptionObserver\n(\nthis\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nonOSSubscriptionChanged\n(\nOSSubscriptionStateChanges\n \nstateChanges\n)\n \n{\n\n    \nif\n \n(!\nstateChanges\n.\ngetFrom\n().\ngetSubscribed\n()\n \n\n        \nstateChanges\n.\ngetTo\n().\ngetSubscribed\n())\n \n{\n\n         \nnew\n \nAlertDialog\n.\nBuilder\n(\nthis\n)\n\n             \n.\nsetMessage\n(\nYou\nve successfully subscribed to push notifications!\n)\n\n             \n.\nshow\n();\n\n        \n// get player ID\n\n        \nstateChanges\n.\ngetTo\n().\ngetUserId\n();\n\n      \n}\n\n\n      \nLog\n.\ni\n(\nDebug\n,\n \nonOSPermissionChanged: \n \n+\n \nstateChanges\n);\n\n  \n}\n\n\n}\n\n\n\n/*\n\n\nExample\n \nLogcat\n \nentry\n \n-\n \nUser\n \ndisabling\n \nnotifications\n \nthen\n \nreturning\n \nto\n \nyour\n \napp\n.\n\n\nonOSSubscriptionChanged:\n\n\n{\nfrom\n:{\npushToken\n:\nAPA91bG9cmZ262s5gJhr8jvbg1q7aiviEC6lcOCgAQliEzHKO3eOdX5cm7IQqMSWfy8Od7Ol3jSjFfvCfeO2UYUpanJCURJ8RdhgEuV8grYxOCwPNJr5GoqcWTQOaL9u-qE2PQcFlv4K\n,\nuserSubscriptionSetting\n:\ntrue\n,\nsubscribed\n:\nfalse\n},\n\n \nto\n:\n  \n{\nuserId\n:\n22712a53-9b5c-4eab-a828-f18f81167fef\n,\npushToken\n:\nAPA91bG9cmZ262s5gJhr8jvbg1q7aiviEC6lcOCgAQliEzHKO3eOdX5cm7IQqMSWfy8Od7Ol3jSjFfvCfeO2UYUpanJCURJ8RdhgEuV8grYxOCwPNJr5GoqcWTQOaL9u-qE2PQcFlv4K\n,\nuserSubscriptionSetting\n:\ntrue\n,\nsubscribed\n:\ntrue\n}}\n\n\n\n\n\n\n\n\n\nKeep a Reference\n\n\nMake sure to hold a reference to your observable at the class level, otherwise it my not fire.\n\n\n\n\n\n\nLeak Safe\n\n\nKontext holds a weak reference to your observer so it's guaranteed not to leak your \nActivity\n.\n\n\n\n\nOSSubscriptionStateChanges\n\n\nCLASS\n\n\nInstance is given to your \nonOSSubscriptionChanged\n method which provides what the value was (\n\"from\"\n) and what the value is now (\n\"to\"\n).\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetFrom()\n\n\nOSPermissionState\n\n\nWhat the state was (past)\n\n\n\n\n\n\ngetTo()\n\n\nOSPermissionState\n\n\nWhat the state is now\n\n\n\n\n\n\n\n\nEvents\n\n\nsendEvent\n\n\nMETHOD\n\n\nTag a user based on an app event of your choosing so later you can create segments in \nSegments\n to target these users. Use \nsendTags\n if you need to set more than one tag on a user at a time.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nString\n\n\nKey of your choosing to create or update.\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nValue to set on the key.\n\n\n\n\n\n\n\n\n1\nKontext\n.\nsendEvents\n(\nkey\n,\n \nvalue\n);\n\n\n\n\n\n\n\nsendEvents\n\n\nMETHOD\n\n\nTag a user based on an app event of your choosing so later you can create segments in \nSegments\n to target these users.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkeyValues\n\n\nJSONObject\n\n\nKey value pairs of your choosing to create or update.\n\n\n\n\n\n\n\n\n1\n2\n3\n4\nJSONObject\n \nevents\n \n=\n \nnew\n \nJSONObject\n();\n\n    \nevents\n.\nput\n(\nkey1\n,\n \nvalue1\n);\n\n    \neventss\n.\nput\n(\nkey2\n,\n \nvalue2\n);\n\n    \nKontext\n.\nsendEvents\n(\nevents\n);\n\n\n\n\n\n\n\nsendScreen\n\n\nMETHOD\n\n\nTag a user based on an screen view event of your choosing so later you can create segments in \nSegments\n to target these users.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkeyValues\n\n\nJSONObject\n\n\nKey value pairs of your choosing to create or update.\n\n\n\n\n\n\n\n\n1\nKontext\n.\nsendEvents\n(\nscreen Name\n);\n\n\n\n\n\n\n\nsendUserAttribute\n\n\nMETHOD\n\n\nTag a user based on their properties like name, age, gender, location, etc.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkeyValues\n\n\nJSONObject\n\n\nKey value pairs of your choosing to create or update.\n\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\nJSONObject\n \nevents\n \n=\n \nnew\n \nJSONObject\n();\n\n    \nevents\n.\nput\n(\nname\n,\n \nJhon Doe\n);\n\n    \neventss\n.\nput\n(\nage\n,\n \n24\n);\n\n    \neventss\n.\nput\n(\ngender\n,\n \nM\n);\n\n    \neventss\n.\nput\n(\ncity\n,\n \nPune\n);\n\n    \nKontext\n.\nsendUserAttributes\n(\nevents\n);\n\n\n\n\n\n\n\nData\n\n\npromptLocation\n\n\nMETHOD\n\n\nPrompts the user for location permissions. This allows for geotagging so you can send notifications to users based on location.\n\n\n1\nKontext\n.\npromptLocation\n();\n\n\n\n\n\n\n\nMake sure you have one of the following permissions in your \nAndroidManifest.xml\n as well.\n\n\n1\n2\nuses-permission\n \nandroid:name=\nandroid.permission.ACCESS_FINE_LOCATION\n/\n\n\nuses-permission\n \nandroid:name=\nandroid.permission.ACCESS_COARSE_LOCATION\n/\n\n\n\n\n\n\n\nsetLocationShared\n\n\nMETHOD\n\n\n1\nKontext\n.\nsetLocationShared\n(\nfalse\n);\n\n\n\n\n\n\n\nDisable or enable location collection (defaults to enabled if your app has location permission).\n\n\nNotifications\n\n\npostNotification\n\n\nMETHOD\n\n\nAllows you to send notifications from user to user or schedule ones in the future to be delivered to the current device.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nparamters\n\n\nJSONObject\n\n\nContains notification options\n\n\n\n\n\n\n\n\ncancelNotification\n\n\nMETHOD\n\n\nCancels a single Kontext notification based on its Android notification integer id. Use instead of Android's \nNotificationManager.cancel(id);\n otherwise the notification will be restored when your app is restarted.\n\n\n1\n2\nint\n \nid\n \n=\n \n1234\n;\n\n\nKontext\n.\ncancelNotification\n(\nid\n);\n\n\n\n\n\n\n\nclearKontextNotifications\n\n\nMETHOD\n\n\nRemoves all Kontext notifications from the Notification Shade. If you just use \nNotificationManager.cancelAll();\nKontext notifications will be restored your app is restarted.\n\n\n1\nKontext\n.\nclearKontextNotifications\n();\n\n\n\n\n\n\n\nsetSubscription\n\n\nMETHOD\n\n\nYou can call this method with false to opt users out of receiving all notifications through Kontext. You can pass true later to opt users back into notifications.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\n\n\n\n\n\n\n\n\nenable\n\n\nboolean\n\n\n\n\n\n\n\n\n1\nKontext\n.\nsetSubscription\n(\nfalse\n);\n\n\n\n\n\n\n\nNotificationExtenderService\n\n\nMETHOD\n\n\nKontext supports sending additional data along with a notification as key value pairs. You can read this additional data when a notification is opened by adding a \nNotificationOpenedHandler\n instead.\n\n\nHowever if you want to do one of the following continue with the instructions below.\n\n\n\n\nReceive data in the background with or without displaying a notification.\n\n\nOverride specific notification settings depending on client side app logic such as custom accent color, vibration pattern, or other any other \nNotificationCompat\n options available.\n\n\n\n\n1.\n Create a class that extents \nNotificationExtenderService\n and implement the \nonNotificationProcessing\n method.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nimport\n \ncom.kontext.OSNotificationPayload\n;\n\n\nimport\n \ncom.kontext.NotificationExtenderService\n;\n\n\n\npublic\n \nclass\n \nNotificationExtenderBareBonesExample\n \nextends\n \nNotificationExtenderService\n \n{\n\n   \n@Override\n\n   \nprotected\n \nboolean\n \nonNotificationProcessing\n(\nOSNotificationReceivedResult\n \nreceivedResult\n)\n \n{\n\n        \n// Read properties from result.\n\n\n      \n// Return true to stop the notification from displaying.\n\n      \nreturn\n \nfalse\n;\n\n   \n}\n\n\n}\n\n\n\n\n\n\n\n2.\n Add the following to your \nAndroidManifest.xml\n.\n\nReplace 'YOUR_CLASS_NAME' with the class name you used above.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nservice\n\n   \nandroid:name=\n.YOUR_CLASS_NAME\n\n   \nandroid:permission=\nandroid.permission.BIND_JOB_SERVICE\n\n   \nandroid:exported=\nfalse\n\n   \nintent-filter\n\n      \naction\n \nandroid:name=\ncom.kontext.NotificationExtender\n \n/\n\n   \n/intent-filter\n\n\n/service\n\n\n\n\n\n\n\n3.\n To override or extend specific notification properties call \ndisplayNotification\n with \nOverrideSettings\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nimport\n \nandroid.support.v4.app.NotificationCompat\n;\n\n\n\nimport\n \ncom.kontext.OSNotificationPayload\n;\n\n\nimport\n \ncom.kontext.NotificationExtenderService\n;\n\n\n\nimport\n \njava.math.BigInteger\n;\n\n\n\npublic\n \nclass\n \nNotificationExtenderExample\n \nextends\n \nNotificationExtenderService\n \n{\n\n   \n@Override\n\n   \nprotected\n \nboolean\n \nonNotificationProcessing\n(\nOSNotificationReceivedResult\n \nreceivedResult\n)\n \n{\n\n      \nOverrideSettings\n \noverrideSettings\n \n=\n \nnew\n \nOverrideSettings\n();\n\n      \noverrideSettings\n.\nextender\n \n=\n \nnew\n \nNotificationCompat\n.\nExtender\n()\n \n{\n\n         \n@Override\n\n         \npublic\n \nNotificationCompat\n.\nBuilder\n \nextend\n(\nNotificationCompat\n.\nBuilder\n \nbuilder\n)\n \n{\n\n            \n// Sets the background notification color to Green on Android 5.0+ devices.\n\n            \nreturn\n \nbuilder\n.\nsetColor\n(\nnew\n \nBigInteger\n(\nFF00FF00\n,\n \n16\n).\nintValue\n());\n\n         \n}\n\n      \n};\n\n\n      \nOSNotificationDisplayedResult\n \ndisplayedResult\n \n=\n \ndisplayNotification\n(\noverrideSettings\n);\n\n            \nLog\n.\nd\n(\nKontextExample\n,\n \nNotification displayed with id: \n \n+\n \ndisplayedResult\n.\nandroidNotificationId\n);\n\n\n      \nreturn\n \ntrue\n;\n\n   \n}\n\n\n}\n\n\n\n\n\n\n\nAdditional Notes\n\n\nNotificationExtenderService\n is an Android \nIntentService\n so please do all your work synchronously. A wake lock is obtained so the device will not sleep while you're processing the payload. \n\n\nEmail\n\n\nsetEmail\n\n\nMETHOD\n\n\nsetEmail\n allows you to set the user's email address with the Kontext SDK. We offer several overloaded versions of this method.\n\n\n1\nKontext\n.\nsetEmail\n(\nexample@domain.com\n);\n\n\n\n\n\n\n\nlogoutEmail\n\n\nMETHOD\n\n\nIf your app implements logout functionality, you can call \nlogoutEmail\n to dissociate the email from the device:\n\n\n1\nKontext\n.\nlogoutEmail\n();\n\n\n\n\n\n\n\naddEmailSubscriptionObserver\n\n\nMETHOD\n\n\nWe have also added a new email subscription observer to track changes to email subscriptions (ie. the user sets their email or logs out). In order to subscribe to email subscription changes you can implement the following:\n\n\n1\nKontext\n.\naddEmailSubscriptionObserver\n(\nsubscriptionObserver\n);\n\n\n\n\n\n\n\nNow, whenever the email subscription changes, this method will be called:\n\n\n1\n2\n3\n4\n5\nOSEmailSubscriptionObserver\n \nsubscriptionObserver\n \n=\n \nnew\n \nOSEmailSubscriptionObserver\n()\n \n{\n\n   \n@Override\n\n   \npublic\n \nvoid\n \nonOSEmailSubscriptionChanged\n(\nOSEmailSubscriptionStateChanges\n \nstateChanges\n)\n \n{\n\n   \n}\n\n\n};\n\n\n\n\n\n\n\nReceiving Notifications\n\n\nNotificationReceivedHandler\n\n\nHANDLER\n\n\nFires when a notification is received. It will be fired when your app is in focus or in the background.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnotification\n\n\nOSNotification\n\n\nContains user's response and properties of the notification.\n\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\nclass\n \nExampleNotificationReceivedHandler\n \nimplements\n \nKontext\n.\nNotificationReceivedHandler\n \n{\n\n  \n@Override\n\n  \npublic\n \nvoid\n \nnotificationReceived\n(\nOSNotification\n \nnotification\n)\n \n{\n\n    \nJSONObject\n \ndata\n \n=\n \nnotification\n.\npayload\n.\nadditionalData\n;\n\n    \nString\n \ncustomKey\n;\n\n\n    \nif\n \n(\ndata\n \n!=\n \nnull\n)\n \n{\n\n      \ncustomKey\n \n=\n \ndata\n.\noptString\n(\ncustomkey\n,\n \nnull\n);\n\n      \nif\n \n(\ncustomKey\n \n!=\n \nnull\n)\n\n        \nLog\n.\ni\n(\nKontxtExample\n,\n \ncustomkey set with value: \n \n+\n \ncustomKey\n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\nImportant Behavior Note\n\n\nIf you will be displaying your own in app message when a notification is received make sure to call inFocusDisplaying with None to disable Kontext's in app AlertBox.\n\n\n\n\nNotificationOpenedHandler\n\n\nHANDLER\n\n\nUse to process a Kontext notification the user just tapped on.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nresult\n\n\nOSNotificationOpenResult\n\n\nContains user's response and properties of the notification.\n\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\nclass\n \nExampleNotificationOpenedHandler\n \nimplements\n \nKontext\n.\nNotificationOpenedHandler\n \n{\n\n  \n// This fires when a notification is opened by tapping on it.\n\n  \n@Override\n\n  \npublic\n \nvoid\n \nnotificationOpened\n(\nOSNotificationOpenResult\n \nresult\n)\n \n{\n\n    \nOSNotificationAction\n.\nActionType\n \nactionType\n \n=\n \nresult\n.\naction\n.\ntype\n;\n\n    \nJSONObject\n \ndata\n \n=\n \nresult\n.\nnotification\n.\npayload\n.\nadditionalData\n;\n\n    \nString\n \ncustomKey\n;\n\n\n    \nif\n \n(\ndata\n \n!=\n \nnull\n)\n \n{\n\n      \ncustomKey\n \n=\n \ndata\n.\noptString\n(\ncustomkey\n,\n \nnull\n);\n\n      \nif\n \n(\ncustomKey\n \n!=\n \nnull\n)\n\n        \nLog\n.\ni\n(\nKontextExample\n,\n \ncustomkey set with value: \n \n+\n \ncustomKey\n);\n\n    \n}\n\n\n    \nif\n \n(\nactionType\n \n==\n \nOSNotificationAction\n.\nActionType\n.\nActionTaken\n)\n\n      \nLog\n.\ni\n(\nKontextExample\n,\n \nButton pressed with id: \n \n+\n \nresult\n.\naction\n.\nactionID\n);\n\n\n    \n// The following can be used to open an Activity of your choice.\n\n    \n// Replace - getApplicationContext() - with any Android Context.\n\n    \n// Intent intent = new Intent(getApplicationContext(), YourActivity.class);\n\n    \n// intent.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT | Intent.FLAG_ACTIVITY_NEW_TASK);\n\n    \n// startActivity(intent);\n\n\n     \n// Add the following to your AndroidManifest.xml to prevent the launching of your main Activity\n\n     \n//   if you are calling startActivity above.\n\n     \n/* \n\n\n        \napplication ...\n\n\n          \nmeta-data android:name=\ncom.kontext.NotificationOpened.DEFAULT\n android:value=\nDISABLE\n /\n\n\n        \n/application\n\n\n     */\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nOSNotificationOpenResult\n\n\nCLASS\n\n\nThe information returned from a notification the user received.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnotification\n\n\nOSNotification\n\n\nNotification the user received.\n\n\n\n\n\n\naction\n\n\nOSNotificationAction\n\n\nThe action the user took on the notification.\n\n\n\n\n\n\n\n\nOSNotification\n\n\nCLASS\n\n\nThe notification the user received.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nisAppInFocus\n\n\nboolean\n\n\nWas app in focus.\n\n\n\n\n\n\nshown\n\n\nboolean\n\n\nWas notification shown to the user. Will be false for silent notifications.\n\n\n\n\n\n\nandroidNotificationId\n\n\nint\n\n\nAndroid Notification assigned to the notification. Can be used to cancel or replace the notification.\n\n\n\n\n\n\npayload\n\n\nOSNotificationPayload\n\n\nPayload received from Kontext.\n\n\n\n\n\n\ndisplayType\n\n\nDisplayType\n\n\nHow the notification was displayed to the user. Can be set to\u00a0\nNotification\n,\u00a0\nInAppAlert\n, or\u00a0\nNone\n\u00a0if it was not displayed.\n\n\n\n\n\n\ngroupedNotifications\n\n\nList\n\n\nNotification is a summary notification for a group this will contain all notification payloads it was created from.\n\n\n\n\n\n\n\n\nDisplayType\n\n\nHow the notification was displayed to the user. Part of \nOSNotification\n. See \ninFocusDisplaying\n for more information on how this is used. \n\n\nNotification\n - native notification display.\n\nInAppAlert\n (DEFAULT) - native alert dialog display.\n\nNone\n - notification is silent, or \ninFocusDisplaying\n is disabled.\n\n\nOSNotificationAction\n\n\nCLASS\n\n\nThe action the user took on the notification.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nActionType\n\n\nWas the notification opened normally (\nOpened\n) or was a button pressed on the notification (\nActionTaken\n).\n\n\n\n\n\n\nactionId\n\n\nString\n\n\nIf\u00a0\ntype\n\u00a0==\u00a0\nActionTaken\n\u00a0then this will contain the id of the button pressed.\n\n\n\n\n\n\n\n\nOSNotificationPayload\n\n\nCLASS\n\n\nContents and settings of the notification the user received.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnotificationID\n\n\nString\n\n\nKontext notification UUID.\n\n\n\n\n\n\ntitle\n\n\nString\n\n\nTitle of the notification.\n\n\n\n\n\n\nbody\n\n\nString\n\n\nBody of the notification.\n\n\n\n\n\n\nadditionalData\n\n\nJSONObject\n\n\nCustom additional data that was sent with the notification.\n\n\n\n\n\n\nsmallIcon\n\n\nString\n\n\nSmall icon resource name set on the notification.\n\n\n\n\n\n\nlargeIcon\n\n\nString\n\n\nLarge icon set on the notification.\n\n\n\n\n\n\nbigPicture\n\n\nString\n\n\nBig picture image set on the notification.\n\n\n\n\n\n\nsmallIconAccentColor\n\n\nString\n\n\nAccent color shown around small notification icon on Android 5+ devices. ARGB format.\n\n\n\n\n\n\nlaunchUrl\n\n\nString\n\n\nURL to open when opening the notification.\n\n\n\n\n\n\nsound\n\n\nString\n\n\nSound resource to play when the notification is shown.\n\n\n\n\n\n\nledColor\n\n\nString\n\n\nDevices that have a notification LED will blink in this color. ARGB format\n\n\n\n\n\n\nlockScreenVisibility\n\n\nint\n\n\nPrivacy setting for how the notification should be shown on the lockscreen of Android 5+ devices.\n \n1\n\u00a0(DEFAULT) - Public (fully visible)\n \n0\n\u00a0- Private (Contents are hidden)\n \n-1\n\u00a0- Secret (not shown).\n\n\n\n\n\n\ngroupKey\n\n\nString\n\n\nNotifications with this same key will be grouped together as a single summary notification.\n\n\n\n\n\n\ngroupMessage\n\n\nstring\n\n\nSummary text displayed in the summary notification.\n\n\n\n\n\n\nactionButtons\n\n\nList\n\n\nList of action buttons on the notification.\n\n\n\n\n\n\nfromProjectNumber\n\n\nString\n\n\nThe Google project number the notification was sent under.\n\n\n\n\n\n\nbackgroundImageLayout\n\n\nBackgroundImageLayout\n\n\nIf a background image was set this object will be available.\n\n\n\n\n\n\nrawPayload\n\n\nString\n\n\nRaw JSON payload string received from  Kontext.\n\n\n\n\n\n\n\n\nActionButton\n\n\nOBJECT\n\n\nList of action buttons on the notification. Part of \nOSNotificationPayload\n.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nid\n\n\nString\n\n\nId assigned to the button.\n\n\n\n\n\n\ntext\n\n\nString\n\n\nText show on the button to the user.\n\n\n\n\n\n\nicon\n\n\nString\n\n\nIcon shown on the button.\n\n\n\n\n\n\n\n\nBackgroundImageLayout\n\n\nOBJECT\n\n\nIf a background image was set, this object will be available. Part of \nOSNotificationPayload\n.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nimage\n\n\nString\n\n\nImage URL or name used as the background image.\n\n\n\n\n\n\ntitleTextColor\n\n\nString\n\n\nText color of the title on the notification. ARGB Format.\n\n\n\n\n\n\nbodyTextColor\n\n\nString\n\n\nText color of the body on the notification. ARGB Format.\n\n\n\n\n\n\n\n\nOpened Action\n\n\nANDROID MANIFEST\n\n\nBy default Kontext will open or resume your launcher Activity when a notification is tapped on. You can disable this behavior by adding the meta-data tag \ncom.kontext.NotificationOpened.DEFAULT\n set to \nDISABLE\n inside your application tag in your \nAndroidManifest.xml\n.\n\n\n1\n2\n3\napplication\n \n...\n\n   \nmeta-data\n \nandroid:name=\ncom.kontext.NotificationOpened.DEFAULT\n \nandroid:value=\nDISABLE\n \n/\n\n\n/application\n\n\n\n\n\n\n\nMake sure you are initializing \nKontext\n with \nsetNotificationOpenedHandler\n in the \nonCreate\n method in your \nApplication\n class. You will need to call \nstartActivity\n from this callback.\n\n\nAppearance\n\n\nenableVibrate\n\n\nMETHOD\n\n\nBy default Kontext always vibrates the device when a notification is displayed unless the device is in a total silent mode. Passing false means that the device will only vibrate lightly when the device is in it's vibrate only mode.\n\n\nYou can link this action to a UI button to give your user a vibration option for your notifications.\n\n\n1\nKontext.enableVibrate(false);\n\n\n\n\n\n\nenableSound\n\n\nMETHOD\n\n\nBy default Kontext plays the system's default notification sound when the device's notification system volume is turned on. Passing false means that the device will only vibrate unless the device is set to a total silent mode.\n\n\nYou can link this action to a UI button to give your user a different sound option for your notifications.\n\n\n1\nKontext\n.\nenableSound\n(\nfalse\n);\n\n\n\n\n\n\n\nDisable Badges\n\n\nANDROID MANIFEST\n\n\nThe Kontext SDK automatically sets the badge count on your app to the number of notifications that are currently in the notification shade. If you want to disable this you can add the following to your \nAndroidManifest.xml\n.\n\n\n1\n2\n3\napplication\n \n...\n\n   \nmeta-data\n \nandroid:name=\ncom.onesignal.BadgeCount\n \nandroid:value=\nDISABLE\n \n/\n\n\n/application\n\n\n\n\n\n\n\nYou can remove the badge permissions with the following entries.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nuses-permission\n \nandroid:name=\ncom.sec.android.provider.badge.permission.READ\n \ntools:node=\nremove\n \n/\n\n\nuses-permission\n \nandroid:name=\ncom.sec.android.provider.badge.permission.WRITE\n \ntools:node=\nremove\n \n/\n\n\nuses-permission\n \nandroid:name=\ncom.htc.launcher.permission.READ_SETTINGS\n \ntools:node=\nremove\n \n/\n\n\nuses-permission\n \nandroid:name=\ncom.htc.launcher.permission.UPDATE_SHORTCUT\n \ntools:node=\nremove\n \n/\n\n\nuses-permission\n \nandroid:name=\ncom.sonyericsson.home.permission.BROADCAST_BADGE\n \ntools:node=\nremove\n \n/\n\n\nuses-permission\n \nandroid:name=\ncom.sonymobile.home.permission.PROVIDER_INSERT_BADGE\n \ntools:node=\nremove\n \n/\n\n\nuses-permission\n \nandroid:name=\ncom.anddoes.launcher.permission.UPDATE_COUNT\n \ntools:node=\nremove\n \n/\n\n\nuses-permission\n \nandroid:name=\ncom.majeur.launcher.permission.UPDATE_BADGE\n \ntools:node=\nremove\n \n/\n\n\nuses-permission\n \nandroid:name=\ncom.huawei.android.launcher.permission.CHANGE_BADGE\n \ntools:node=\nremove\n/\n\n\nuses-permission\n \nandroid:name=\ncom.huawei.android.launcher.permission.READ_SETTINGS\n \ntools:node=\nremove\n \n/\n\n\nuses-permission\n \nandroid:name=\ncom.huawei.android.launcher.permission.WRITE_SETTINGS\n \ntools:node=\nremove\n \n/\n\n\n\n\n\n\n\nDebug\n\n\nsetLogLevel\n\n\nMETHOD\n\n\nEnable logging to help debug if you run into an issue setting up Kontext. The following options are available with increasingly more information; \nNONE\n, \nFATAL\n, \nERROR\n, \nWARN\n, \nINFO\n, \nDEBUG\n, \nVERBOSE\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlogLevel\n\n\nLOG_LEVEL\n\n\nSets the logging level to print to the Android LogCat log.\n\n\n\n\n\n\nvisualLevel\n\n\nLOG_LEVEL\n\n\nSets the logging level to show as alert dialogs.\n\n\n\n\n\n\n\n\n1\nKontext\n.\nsetLogLevel\n(\nKontext\n.\nLOG_LEVEL\n.\nDEBUG\n,\n \nKontext\n.\nLOG_LEVEL\n.\nDEBUG\n);", 
            "title": "SDK Reference"
        }, 
        {
            "location": "/android/reference/#initialization", 
            "text": "", 
            "title": "Initialization"
        }, 
        {
            "location": "/android/reference/#init", 
            "text": "BUILDER METHOD  Initializes Kontext to register the device for push notifications. Should be called in the  onCreate  method of your Application class.  1 Kontext . startInit ( this ). init ();", 
            "title": "init"
        }, 
        {
            "location": "/android/reference/#startinit", 
            "text": "METHOD  Initializes Kontext to register the device for push notifications. Should be call in the  onCreate  of your Application class.     Parameter  Type  Description      context  Context  Your Application Kontext.     Returns  Kontext.Builder  - See below for a list of methods available.  1\n2\n3\n4\n5\n6\n7 public   class   YourAppClass   extends   Application   { \n    @Override \n    public   void   onCreate ()   { \n       super . onCreate (); \n       Kontext . startInit ( this ). init (); \n    }  }", 
            "title": "startInit"
        }, 
        {
            "location": "/android/reference/#autopromptlocation", 
            "text": "BUILDER METHOD  Prompts the user for location permissions. This allows for geotagging so you can send notifications to users based on location. See  promptLocation  for more details.     Parameter  Type  Description      prompt  boolean  false   (DEFAULT) - do not prompt true   -  prompt users for location permissions when your app starts.     1\n2\n3 Kontext . startInit ( this ) \n   . autoPromptLocation ( true ) \n   . init ();", 
            "title": "autoPromptLocation"
        }, 
        {
            "location": "/android/reference/#setnotificationreceivedhandler", 
            "text": "BUILDER METHOD  Sets a notification received handler that will fire when a notification is received. It will be fired when your app is in focus or in the background.     Parameter  Type  Description      handler  NotificationReceivedHandler  Instance to a class implementing this interference.     1\n2\n3 Kontext . startInit ( this )    \n    . setNotificationReceivedHandler ( new   ExampleNotificationReceivedHandler ()) \n    . init ();", 
            "title": "setNotificationReceivedHandler"
        }, 
        {
            "location": "/android/reference/#setnotificationopenedhandler", 
            "text": "BUILDER METHOD  Sets a notification opened handler. The instance will be called when a notification is tapped on from the notification shade or when closing an Alert notification shown in the app.     Parameter  Type  Description      hndler  NotificationOpenedHandler  Instance to a class implementing this interference.     1\n2\n3 Kontext . startInit ( this )    \n    . setNotificationOpenedHandler ( new   ExampleNotificationOpenedHandler ()) \n    . init ();", 
            "title": "setNotificationOpenedHandler"
        }, 
        {
            "location": "/android/reference/#setinfocusdisplaying", 
            "text": "METHOD  Setting to control how Kontext notifications will be shown when one is received while your app is in focus.  Notification  - native notification display while user has app in focus (can be distracting). InAppAlert  (DEFAULT) - native alert dialog display, which can be helpful during development. None  - notification is silent.  1 Kontext . setInFocusDisplaying ( Kontext . OSInFocusDisplayOption . Notification );", 
            "title": "setInFocusDisplaying"
        }, 
        {
            "location": "/android/reference/#privacy", 
            "text": "", 
            "title": "Privacy"
        }, 
        {
            "location": "/android/reference/#setrequiresuserprivacyconsent", 
            "text": "METHOD  Lets your app require the user's privacy consent before it will initialize. If you call this method and pass in  true , the SDK will delay initialization until your application calls `provideUserConsent(true).  If the SDK is waiting for the user's consent, calling any Kontext SDK methods will do nothing but print a warning. The user will not be registered for push notifications until this happens.  1\n2 // the SDK will delay initialization and won t collect data.  Kontext . setRequiresUserPrivacyConsent ( true );", 
            "title": "setRequiresUserPrivacyConsent"
        }, 
        {
            "location": "/android/reference/#provideuserconsent", 
            "text": "If your application is set to require the user's privacy consent, you can provide this consent using this method. Until you call  provideUserConsent(true) , the SDK will not fully initialize and will not send any data to Kontext.  1\n2\n3\n4 public   void   onUserTappedProvidePrivacyConsent ( View   v )   { \n   //will initialize the Kontext SDK and enable push notifications \n   Kontext . provideUserConsent ( true );  }", 
            "title": "provideUserConsent"
        }, 
        {
            "location": "/android/reference/#userprovidedprivacyconsent", 
            "text": "METHOD  Returns a boolean indicating if the user has provided privacy consent.", 
            "title": "userProvidedPrivacyConsent"
        }, 
        {
            "location": "/android/reference/#disablegmsmissingprompt", 
            "text": "BUILDER METHOD  Prompts the user to update/enable Google Play services if it's disabled on the device.     Parameter  Type  Description      prompt  boolean  false  (DEFAULT) - prompt users   true \u00a0to never show the out of date prompt.     1\n2\n3 Kontext . startInit ( this ) \n   . disableGmsMissingPrompt ( true ) \n   . init ();", 
            "title": "disableGmsMissingPrompt"
        }, 
        {
            "location": "/android/reference/#unsubscribewhennotificationsaredisabled", 
            "text": "BUILDER METHOD  If notifications are disabled for your app, unsubscribe the user from Kontext. This will happen when your users go to Settings   Apps and turn off notifications, or if they long press one of your notifications and select \"block notifications\".\nThis is  false  by default.     Parameter  Type  Description      prompt  boolean  false  (DEFAULT) - prompt users   true \u00a0to never show the out of date prompt.     1\n2\n3 Kontext . startInit ( this ) \n   . disableGmsMissingPrompt ( true ) \n   . init ();", 
            "title": "unsubscribeWhenNotificationsAreDisabled"
        }, 
        {
            "location": "/android/reference/#unsubscribewhennotificationsaredisabled_1", 
            "text": "BUILDER METHOD  If notifications are disabled for your app, unsubscribe the user from Kontext. This will happen when your users go to Settings   Apps and turn off notifications, or if they long press one of your notifications and select \"block notifications\".\nThis is  false  by default.     Parameter  Type  Description      prompt  boolean  false \u00a0(DEFAULT) - don't unsubscribe users   true \u00a0- unsubscribe users when notifications are disabled     1\n2\n3 Kontext . startInit ( this ) \n   . unsubscribeWhenNotificationsAreDisabled ( true ) \n   . init ();", 
            "title": "unsubscribeWhenNotificationsAreDisabled"
        }, 
        {
            "location": "/android/reference/#status-methods", 
            "text": "The following methods provide details on the permission and subscribed state of the device. Use  getPermissionSubscriptionState  to get the current immediate state and use  addPermissionObserver  and / or  addSubscriptionObserver  to react to changes.", 
            "title": "Status methods"
        }, 
        {
            "location": "/android/reference/#status-recommendations", 
            "text": "getPermissionSubscriptionState  - Use to load your UI to the correct state. Such as showing a toggle button to enable notifications.  addSubscriptionObserver  - Use to update your server when the user becomes subscribed or unsubscribed and to get the Kontext player / user id.\nExample if you need to store the Kontext player / user id on your backend you can make a REST API call directly from the observer's callback. The Kontext observer ONLY fires when there is a change, including NOT firing even if the app has been restarted. This helps ensure your not making unnecessary network calls to your backend on each app restart if nothing changed.", 
            "title": "Status Recommendations"
        }, 
        {
            "location": "/android/reference/#getpermissionsubscriptionstate", 
            "text": "METHOD  Get the current notification and permission state. Returns a  OSPermissionSubscriptionState  type described below.     Parameter  Type  Description      getPermissionStatus()  OSPermissionState  Android Notification Permissions state    getSubscriptionStatus()  OSSubscriptionState  Google and  Kontext subscription state     1\n2\n3\n4\n5\n6\n7 OSPermissionSubscriptionState   status   =   Kontext . getPermissionSubscriptionState ();  status . getPermissionStatus (). getEnabled ();  status . getSubscriptionStatus (). getSubscribed ();  status . getSubscriptionStatus (). getUserSubscriptionSetting ();  status . getSubscriptionStatus (). getUserId ();  status . getSubscriptionStatus (). getPushToken ();", 
            "title": "getPermissionSubscriptionState"
        }, 
        {
            "location": "/android/reference/#ospermissionstate", 
            "text": "CLASS  The Notification permission status of your app. Contains enabled value to know if the user has turned off notifications for your app.     Parameter  Type  Description      getEnabled()  boolean  true \u00a0if notifications are enabled.  Will only be\u00a0 false \u00a0if the user disables notifications for your app from the system settings", 
            "title": "OSPermissionState"
        }, 
        {
            "location": "/android/reference/#ossubscriptionstate", 
            "text": "CLASS  Provides subscription state details of subscribed to push as well as the Kontext player / user id and the devices push token.     Parameter  Type  Description      getSubscribed()  boolean  true \u00a0if the device can receive push notifications from  Kontext.   false \u00a0if the device has disabled push notifications or not successfully registered yet with either  Kontext or FCM with a valid push token.    getUserId()  String  The  Kontext player / user id for the device.  null \u00a0if the device hasn't registered with  Kontext's server yet.    getPushToken()  String  The GCM / FCM push token for the device.  null \u00a0if the device hasn't registered with Google's server yet.", 
            "title": "OSSubscriptionState"
        }, 
        {
            "location": "/android/reference/#addpermissionobserver", 
            "text": "HANDLER  The  onOSPermissionChanged  method will be fired on the passed-in object when a notification permission setting changes. This happens when the user enables or disables notifications for your app from the system settings outside of your app. Disable detection is supported on Android 4.4+.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 public   class   MainActivity   extends   Activity   implements   OSPermissionObserver   { \n   protected   void   onCreate ( Bundle   savedInstanceState )   { \n     Kontext . addPermissionObserver ( this ); \n   } \n\n   public   void   onOSPermissionChanged ( OSPermissionStateChanges   stateChanges )   { \n     if   ( stateChanges . getFrom (). getEnabled ()   \n         ! stateChanges . getTo (). getEnabled ())   { \n          new   AlertDialog . Builder ( this ) \n              . setMessage ( Notifications Disabled! ) \n              . show (); \n       } \n\n       Log . i ( Debug ,   onOSPermissionChanged:    +   stateChanges ); \n   }  }  // Example Logcat entry - User disabling notifications then returning to your app.  // onOSPermissionChanged{ from :{ enabled :true}, to :{ enabled :false}}     Keep a Reference  Make sure to hold a reference to your observable at the class level, otherwise it my not fire.    Leak Safe  Kontext holds a weak reference to your observer so it's guaranteed not to leak your  Activity .", 
            "title": "addPermissionObserver"
        }, 
        {
            "location": "/android/reference/#ospermissionstatechanges", 
            "text": "CLASS  Instance is given to your  onOSPermissionChanged  method which provides what the value was ( \"from\" ) and what the value is now ( \"to\" ).     Parameter  Type  Description      getFrom()  OSSubscriptionState  What the state was    getTo()  OSSubscriptionState  What the state is now", 
            "title": "OSPermissionStateChanges"
        }, 
        {
            "location": "/android/reference/#addsubscriptionobserver", 
            "text": "METHOD  The  onOSSubscriptionChanged  method will be fired on the passed-in object when a notification subscription property changes.  This includes the following events:   Getting a Registration Id (push token) from Google  Getting a player / user id from Kontext  Kontext.setSubscription  is called  User disables or enables notifications    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24 public   class   MainActivity   extends   Activity   implements   OSSubscriptionObserver   { \n   protected   void   onCreate ( Bundle   savedInstanceState )   { \n     Kontext . addSubscriptionObserver ( this ); \n   } \n\n   public   void   onOSSubscriptionChanged ( OSSubscriptionStateChanges   stateChanges )   { \n     if   (! stateChanges . getFrom (). getSubscribed ()   \n         stateChanges . getTo (). getSubscribed ())   { \n          new   AlertDialog . Builder ( this ) \n              . setMessage ( You ve successfully subscribed to push notifications! ) \n              . show (); \n         // get player ID \n         stateChanges . getTo (). getUserId (); \n       } \n\n       Log . i ( Debug ,   onOSPermissionChanged:    +   stateChanges ); \n   }  }  /*  Example   Logcat   entry   -   User   disabling   notifications   then   returning   to   your   app .  onOSSubscriptionChanged:  { from :{ pushToken : APA91bG9cmZ262s5gJhr8jvbg1q7aiviEC6lcOCgAQliEzHKO3eOdX5cm7IQqMSWfy8Od7Ol3jSjFfvCfeO2UYUpanJCURJ8RdhgEuV8grYxOCwPNJr5GoqcWTQOaL9u-qE2PQcFlv4K , userSubscriptionSetting : true , subscribed : false }, \n  to :    { userId : 22712a53-9b5c-4eab-a828-f18f81167fef , pushToken : APA91bG9cmZ262s5gJhr8jvbg1q7aiviEC6lcOCgAQliEzHKO3eOdX5cm7IQqMSWfy8Od7Ol3jSjFfvCfeO2UYUpanJCURJ8RdhgEuV8grYxOCwPNJr5GoqcWTQOaL9u-qE2PQcFlv4K , userSubscriptionSetting : true , subscribed : true }}     Keep a Reference  Make sure to hold a reference to your observable at the class level, otherwise it my not fire.    Leak Safe  Kontext holds a weak reference to your observer so it's guaranteed not to leak your  Activity .", 
            "title": "addSubscriptionObserver"
        }, 
        {
            "location": "/android/reference/#ossubscriptionstatechanges", 
            "text": "CLASS  Instance is given to your  onOSSubscriptionChanged  method which provides what the value was ( \"from\" ) and what the value is now ( \"to\" ).     Parameter  Type  Description      getFrom()  OSPermissionState  What the state was (past)    getTo()  OSPermissionState  What the state is now", 
            "title": "OSSubscriptionStateChanges"
        }, 
        {
            "location": "/android/reference/#events", 
            "text": "", 
            "title": "Events"
        }, 
        {
            "location": "/android/reference/#sendevent", 
            "text": "METHOD  Tag a user based on an app event of your choosing so later you can create segments in  Segments  to target these users. Use  sendTags  if you need to set more than one tag on a user at a time.     Parameter  Type  Description      key  String  Key of your choosing to create or update.    value  String  Value to set on the key.     1 Kontext . sendEvents ( key ,   value );", 
            "title": "sendEvent"
        }, 
        {
            "location": "/android/reference/#sendevents", 
            "text": "METHOD  Tag a user based on an app event of your choosing so later you can create segments in  Segments  to target these users.     Parameter  Type  Description      keyValues  JSONObject  Key value pairs of your choosing to create or update.     1\n2\n3\n4 JSONObject   events   =   new   JSONObject (); \n     events . put ( key1 ,   value1 ); \n     eventss . put ( key2 ,   value2 ); \n     Kontext . sendEvents ( events );", 
            "title": "sendEvents"
        }, 
        {
            "location": "/android/reference/#sendscreen", 
            "text": "METHOD  Tag a user based on an screen view event of your choosing so later you can create segments in  Segments  to target these users.     Parameter  Type  Description      keyValues  JSONObject  Key value pairs of your choosing to create or update.     1 Kontext . sendEvents ( screen Name );", 
            "title": "sendScreen"
        }, 
        {
            "location": "/android/reference/#senduserattribute", 
            "text": "METHOD  Tag a user based on their properties like name, age, gender, location, etc.     Parameter  Type  Description      keyValues  JSONObject  Key value pairs of your choosing to create or update.     1\n2\n3\n4\n5\n6 JSONObject   events   =   new   JSONObject (); \n     events . put ( name ,   Jhon Doe ); \n     eventss . put ( age ,   24 ); \n     eventss . put ( gender ,   M ); \n     eventss . put ( city ,   Pune ); \n     Kontext . sendUserAttributes ( events );", 
            "title": "sendUserAttribute"
        }, 
        {
            "location": "/android/reference/#data", 
            "text": "", 
            "title": "Data"
        }, 
        {
            "location": "/android/reference/#promptlocation", 
            "text": "METHOD  Prompts the user for location permissions. This allows for geotagging so you can send notifications to users based on location.  1 Kontext . promptLocation ();    Make sure you have one of the following permissions in your  AndroidManifest.xml  as well.  1\n2 uses-permission   android:name= android.permission.ACCESS_FINE_LOCATION /  uses-permission   android:name= android.permission.ACCESS_COARSE_LOCATION /", 
            "title": "promptLocation"
        }, 
        {
            "location": "/android/reference/#setlocationshared", 
            "text": "METHOD  1 Kontext . setLocationShared ( false );    Disable or enable location collection (defaults to enabled if your app has location permission).", 
            "title": "setLocationShared"
        }, 
        {
            "location": "/android/reference/#notifications", 
            "text": "", 
            "title": "Notifications"
        }, 
        {
            "location": "/android/reference/#postnotification", 
            "text": "METHOD  Allows you to send notifications from user to user or schedule ones in the future to be delivered to the current device.     Parameter  Type  Description      paramters  JSONObject  Contains notification options", 
            "title": "postNotification"
        }, 
        {
            "location": "/android/reference/#cancelnotification", 
            "text": "METHOD  Cancels a single Kontext notification based on its Android notification integer id. Use instead of Android's  NotificationManager.cancel(id);  otherwise the notification will be restored when your app is restarted.  1\n2 int   id   =   1234 ;  Kontext . cancelNotification ( id );", 
            "title": "cancelNotification"
        }, 
        {
            "location": "/android/reference/#clearkontextnotifications", 
            "text": "METHOD  Removes all Kontext notifications from the Notification Shade. If you just use  NotificationManager.cancelAll(); Kontext notifications will be restored your app is restarted.  1 Kontext . clearKontextNotifications ();", 
            "title": "clearKontextNotifications"
        }, 
        {
            "location": "/android/reference/#setsubscription", 
            "text": "METHOD  You can call this method with false to opt users out of receiving all notifications through Kontext. You can pass true later to opt users back into notifications.     Parameter  Type      enable  boolean     1 Kontext . setSubscription ( false );", 
            "title": "setSubscription"
        }, 
        {
            "location": "/android/reference/#notificationextenderservice", 
            "text": "METHOD  Kontext supports sending additional data along with a notification as key value pairs. You can read this additional data when a notification is opened by adding a  NotificationOpenedHandler  instead.  However if you want to do one of the following continue with the instructions below.   Receive data in the background with or without displaying a notification.  Override specific notification settings depending on client side app logic such as custom accent color, vibration pattern, or other any other  NotificationCompat  options available.   1.  Create a class that extents  NotificationExtenderService  and implement the  onNotificationProcessing  method.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 import   com.kontext.OSNotificationPayload ;  import   com.kontext.NotificationExtenderService ;  public   class   NotificationExtenderBareBonesExample   extends   NotificationExtenderService   { \n    @Override \n    protected   boolean   onNotificationProcessing ( OSNotificationReceivedResult   receivedResult )   { \n         // Read properties from result. \n\n       // Return true to stop the notification from displaying. \n       return   false ; \n    }  }    2.  Add the following to your  AndroidManifest.xml . Replace 'YOUR_CLASS_NAME' with the class name you used above.  1\n2\n3\n4\n5\n6\n7\n8 service \n    android:name= .YOUR_CLASS_NAME \n    android:permission= android.permission.BIND_JOB_SERVICE \n    android:exported= false \n    intent-filter \n       action   android:name= com.kontext.NotificationExtender   / \n    /intent-filter  /service    3.  To override or extend specific notification properties call  displayNotification  with  OverrideSettings .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25 import   android.support.v4.app.NotificationCompat ;  import   com.kontext.OSNotificationPayload ;  import   com.kontext.NotificationExtenderService ;  import   java.math.BigInteger ;  public   class   NotificationExtenderExample   extends   NotificationExtenderService   { \n    @Override \n    protected   boolean   onNotificationProcessing ( OSNotificationReceivedResult   receivedResult )   { \n       OverrideSettings   overrideSettings   =   new   OverrideSettings (); \n       overrideSettings . extender   =   new   NotificationCompat . Extender ()   { \n          @Override \n          public   NotificationCompat . Builder   extend ( NotificationCompat . Builder   builder )   { \n             // Sets the background notification color to Green on Android 5.0+ devices. \n             return   builder . setColor ( new   BigInteger ( FF00FF00 ,   16 ). intValue ()); \n          } \n       }; \n\n       OSNotificationDisplayedResult   displayedResult   =   displayNotification ( overrideSettings ); \n             Log . d ( KontextExample ,   Notification displayed with id:    +   displayedResult . androidNotificationId ); \n\n       return   true ; \n    }  }    Additional Notes  NotificationExtenderService  is an Android  IntentService  so please do all your work synchronously. A wake lock is obtained so the device will not sleep while you're processing the payload.", 
            "title": "NotificationExtenderService"
        }, 
        {
            "location": "/android/reference/#email", 
            "text": "", 
            "title": "Email"
        }, 
        {
            "location": "/android/reference/#setemail", 
            "text": "METHOD  setEmail  allows you to set the user's email address with the Kontext SDK. We offer several overloaded versions of this method.  1 Kontext . setEmail ( example@domain.com );", 
            "title": "setEmail"
        }, 
        {
            "location": "/android/reference/#logoutemail", 
            "text": "METHOD  If your app implements logout functionality, you can call  logoutEmail  to dissociate the email from the device:  1 Kontext . logoutEmail ();", 
            "title": "logoutEmail"
        }, 
        {
            "location": "/android/reference/#addemailsubscriptionobserver", 
            "text": "METHOD  We have also added a new email subscription observer to track changes to email subscriptions (ie. the user sets their email or logs out). In order to subscribe to email subscription changes you can implement the following:  1 Kontext . addEmailSubscriptionObserver ( subscriptionObserver );    Now, whenever the email subscription changes, this method will be called:  1\n2\n3\n4\n5 OSEmailSubscriptionObserver   subscriptionObserver   =   new   OSEmailSubscriptionObserver ()   { \n    @Override \n    public   void   onOSEmailSubscriptionChanged ( OSEmailSubscriptionStateChanges   stateChanges )   { \n    }  };", 
            "title": "addEmailSubscriptionObserver"
        }, 
        {
            "location": "/android/reference/#receiving-notifications", 
            "text": "", 
            "title": "Receiving Notifications"
        }, 
        {
            "location": "/android/reference/#notificationreceivedhandler", 
            "text": "HANDLER  Fires when a notification is received. It will be fired when your app is in focus or in the background.     Parameter  Type  Description      notification  OSNotification  Contains user's response and properties of the notification.      1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 class   ExampleNotificationReceivedHandler   implements   Kontext . NotificationReceivedHandler   { \n   @Override \n   public   void   notificationReceived ( OSNotification   notification )   { \n     JSONObject   data   =   notification . payload . additionalData ; \n     String   customKey ; \n\n     if   ( data   !=   null )   { \n       customKey   =   data . optString ( customkey ,   null ); \n       if   ( customKey   !=   null ) \n         Log . i ( KontxtExample ,   customkey set with value:    +   customKey ); \n     } \n   }  }     Important Behavior Note  If you will be displaying your own in app message when a notification is received make sure to call inFocusDisplaying with None to disable Kontext's in app AlertBox.", 
            "title": "NotificationReceivedHandler"
        }, 
        {
            "location": "/android/reference/#notificationopenedhandler", 
            "text": "HANDLER  Use to process a Kontext notification the user just tapped on.     Parameter  Type  Description      result  OSNotificationOpenResult  Contains user's response and properties of the notification.      1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32 class   ExampleNotificationOpenedHandler   implements   Kontext . NotificationOpenedHandler   { \n   // This fires when a notification is opened by tapping on it. \n   @Override \n   public   void   notificationOpened ( OSNotificationOpenResult   result )   { \n     OSNotificationAction . ActionType   actionType   =   result . action . type ; \n     JSONObject   data   =   result . notification . payload . additionalData ; \n     String   customKey ; \n\n     if   ( data   !=   null )   { \n       customKey   =   data . optString ( customkey ,   null ); \n       if   ( customKey   !=   null ) \n         Log . i ( KontextExample ,   customkey set with value:    +   customKey ); \n     } \n\n     if   ( actionType   ==   OSNotificationAction . ActionType . ActionTaken ) \n       Log . i ( KontextExample ,   Button pressed with id:    +   result . action . actionID ); \n\n     // The following can be used to open an Activity of your choice. \n     // Replace - getApplicationContext() - with any Android Context. \n     // Intent intent = new Intent(getApplicationContext(), YourActivity.class); \n     // intent.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT | Intent.FLAG_ACTIVITY_NEW_TASK); \n     // startActivity(intent); \n\n      // Add the following to your AndroidManifest.xml to prevent the launching of your main Activity \n      //   if you are calling startActivity above. \n      /*            application ...             meta-data android:name= com.kontext.NotificationOpened.DEFAULT  android:value= DISABLE  /           /application       */ \n   }  }", 
            "title": "NotificationOpenedHandler"
        }, 
        {
            "location": "/android/reference/#osnotificationopenresult", 
            "text": "CLASS  The information returned from a notification the user received.     Parameter  Type  Description      notification  OSNotification  Notification the user received.    action  OSNotificationAction  The action the user took on the notification.", 
            "title": "OSNotificationOpenResult"
        }, 
        {
            "location": "/android/reference/#osnotification", 
            "text": "CLASS  The notification the user received.     Parameter  Type  Description      isAppInFocus  boolean  Was app in focus.    shown  boolean  Was notification shown to the user. Will be false for silent notifications.    androidNotificationId  int  Android Notification assigned to the notification. Can be used to cancel or replace the notification.    payload  OSNotificationPayload  Payload received from Kontext.    displayType  DisplayType  How the notification was displayed to the user. Can be set to\u00a0 Notification ,\u00a0 InAppAlert , or\u00a0 None \u00a0if it was not displayed.    groupedNotifications  List  Notification is a summary notification for a group this will contain all notification payloads it was created from.", 
            "title": "OSNotification"
        }, 
        {
            "location": "/android/reference/#displaytype", 
            "text": "How the notification was displayed to the user. Part of  OSNotification . See  inFocusDisplaying  for more information on how this is used.   Notification  - native notification display. InAppAlert  (DEFAULT) - native alert dialog display. None  - notification is silent, or  inFocusDisplaying  is disabled.", 
            "title": "DisplayType"
        }, 
        {
            "location": "/android/reference/#osnotificationaction", 
            "text": "CLASS  The action the user took on the notification.     Parameter  Type  Description      type  ActionType  Was the notification opened normally ( Opened ) or was a button pressed on the notification ( ActionTaken ).    actionId  String  If\u00a0 type \u00a0==\u00a0 ActionTaken \u00a0then this will contain the id of the button pressed.", 
            "title": "OSNotificationAction"
        }, 
        {
            "location": "/android/reference/#osnotificationpayload", 
            "text": "CLASS  Contents and settings of the notification the user received.     Parameter  Type  Description      notificationID  String  Kontext notification UUID.    title  String  Title of the notification.    body  String  Body of the notification.    additionalData  JSONObject  Custom additional data that was sent with the notification.    smallIcon  String  Small icon resource name set on the notification.    largeIcon  String  Large icon set on the notification.    bigPicture  String  Big picture image set on the notification.    smallIconAccentColor  String  Accent color shown around small notification icon on Android 5+ devices. ARGB format.    launchUrl  String  URL to open when opening the notification.    sound  String  Sound resource to play when the notification is shown.    ledColor  String  Devices that have a notification LED will blink in this color. ARGB format    lockScreenVisibility  int  Privacy setting for how the notification should be shown on the lockscreen of Android 5+ devices.   1 \u00a0(DEFAULT) - Public (fully visible)   0 \u00a0- Private (Contents are hidden)   -1 \u00a0- Secret (not shown).    groupKey  String  Notifications with this same key will be grouped together as a single summary notification.    groupMessage  string  Summary text displayed in the summary notification.    actionButtons  List  List of action buttons on the notification.    fromProjectNumber  String  The Google project number the notification was sent under.    backgroundImageLayout  BackgroundImageLayout  If a background image was set this object will be available.    rawPayload  String  Raw JSON payload string received from  Kontext.", 
            "title": "OSNotificationPayload"
        }, 
        {
            "location": "/android/reference/#actionbutton", 
            "text": "OBJECT  List of action buttons on the notification. Part of  OSNotificationPayload .     Parameter  Type  Description      id  String  Id assigned to the button.    text  String  Text show on the button to the user.    icon  String  Icon shown on the button.", 
            "title": "ActionButton"
        }, 
        {
            "location": "/android/reference/#backgroundimagelayout", 
            "text": "OBJECT  If a background image was set, this object will be available. Part of  OSNotificationPayload .     Parameter  Type  Description      image  String  Image URL or name used as the background image.    titleTextColor  String  Text color of the title on the notification. ARGB Format.    bodyTextColor  String  Text color of the body on the notification. ARGB Format.", 
            "title": "BackgroundImageLayout"
        }, 
        {
            "location": "/android/reference/#opened-action", 
            "text": "ANDROID MANIFEST  By default Kontext will open or resume your launcher Activity when a notification is tapped on. You can disable this behavior by adding the meta-data tag  com.kontext.NotificationOpened.DEFAULT  set to  DISABLE  inside your application tag in your  AndroidManifest.xml .  1\n2\n3 application   ... \n    meta-data   android:name= com.kontext.NotificationOpened.DEFAULT   android:value= DISABLE   /  /application    Make sure you are initializing  Kontext  with  setNotificationOpenedHandler  in the  onCreate  method in your  Application  class. You will need to call  startActivity  from this callback.", 
            "title": "Opened Action"
        }, 
        {
            "location": "/android/reference/#appearance", 
            "text": "", 
            "title": "Appearance"
        }, 
        {
            "location": "/android/reference/#enablevibrate", 
            "text": "METHOD  By default Kontext always vibrates the device when a notification is displayed unless the device is in a total silent mode. Passing false means that the device will only vibrate lightly when the device is in it's vibrate only mode.  You can link this action to a UI button to give your user a vibration option for your notifications.  1 Kontext.enableVibrate(false);", 
            "title": "enableVibrate"
        }, 
        {
            "location": "/android/reference/#enablesound", 
            "text": "METHOD  By default Kontext plays the system's default notification sound when the device's notification system volume is turned on. Passing false means that the device will only vibrate unless the device is set to a total silent mode.  You can link this action to a UI button to give your user a different sound option for your notifications.  1 Kontext . enableSound ( false );", 
            "title": "enableSound"
        }, 
        {
            "location": "/android/reference/#disable-badges", 
            "text": "ANDROID MANIFEST  The Kontext SDK automatically sets the badge count on your app to the number of notifications that are currently in the notification shade. If you want to disable this you can add the following to your  AndroidManifest.xml .  1\n2\n3 application   ... \n    meta-data   android:name= com.onesignal.BadgeCount   android:value= DISABLE   /  /application    You can remove the badge permissions with the following entries.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 uses-permission   android:name= com.sec.android.provider.badge.permission.READ   tools:node= remove   /  uses-permission   android:name= com.sec.android.provider.badge.permission.WRITE   tools:node= remove   /  uses-permission   android:name= com.htc.launcher.permission.READ_SETTINGS   tools:node= remove   /  uses-permission   android:name= com.htc.launcher.permission.UPDATE_SHORTCUT   tools:node= remove   /  uses-permission   android:name= com.sonyericsson.home.permission.BROADCAST_BADGE   tools:node= remove   /  uses-permission   android:name= com.sonymobile.home.permission.PROVIDER_INSERT_BADGE   tools:node= remove   /  uses-permission   android:name= com.anddoes.launcher.permission.UPDATE_COUNT   tools:node= remove   /  uses-permission   android:name= com.majeur.launcher.permission.UPDATE_BADGE   tools:node= remove   /  uses-permission   android:name= com.huawei.android.launcher.permission.CHANGE_BADGE   tools:node= remove /  uses-permission   android:name= com.huawei.android.launcher.permission.READ_SETTINGS   tools:node= remove   /  uses-permission   android:name= com.huawei.android.launcher.permission.WRITE_SETTINGS   tools:node= remove   /", 
            "title": "Disable Badges"
        }, 
        {
            "location": "/android/reference/#debug", 
            "text": "", 
            "title": "Debug"
        }, 
        {
            "location": "/android/reference/#setloglevel", 
            "text": "METHOD  Enable logging to help debug if you run into an issue setting up Kontext. The following options are available with increasingly more information;  NONE ,  FATAL ,  ERROR ,  WARN ,  INFO ,  DEBUG ,  VERBOSE     Parameter  Type  Description      logLevel  LOG_LEVEL  Sets the logging level to print to the Android LogCat log.    visualLevel  LOG_LEVEL  Sets the logging level to show as alert dialogs.     1 Kontext . setLogLevel ( Kontext . LOG_LEVEL . DEBUG ,   Kontext . LOG_LEVEL . DEBUG );", 
            "title": "setLogLevel"
        }, 
        {
            "location": "/android/firebasekey/", 
            "text": "Generate a Firebase Server Key\n\n\nYour \nFirebase Server Key\n and \nFirebase Sender ID\n are used to send push notifications to ANDROID devices.\n\n\nTo begin, we'll obtain a Firebase Server Key and Firebase Sender ID. These keys allow Kontext to use Google's web push services for your notifications.\n\n\n1. Create a Firebase project\n\n\n1.1\n Visit the \nFirebase Console\n and sign in with your Google account.\n\n\n\n\n1.2\n\u00a0Press \"CREATE NEW PROJECT\" or select an existing one below.\n\n\n\n\n1.3\n\u00a0Enter a project name and press \"CREATE PROJECT\".\n\n\n\n\n2. Getting your Firebase Cloud Messaging token and Sender ID\n\n\n2.1\n Click the Gear icon in the top left and select \"Project settings\".\n\n\n2.2\n Select the \"CLOUD MESSAGING\" tab.\n\n\n2.3\n Save the two values listed:\n\n\n\n\nYou'll need your \nServer key\n and \nSender ID\n.\n\n\n\n\n\n\n3. Configure your Kontext app's Android platform settings\n\n\n3.1\n Go to Settings and paste your \nSender ID and FCM credentials\n.\n\n\n3.2\n Press Save to generate your app ID and key.\n\n\n\n\n\n\nDone!!!\n\n\nYou now have a key to send push notifications from your Android app.", 
            "title": "Generate Firebase Key"
        }, 
        {
            "location": "/android/firebasekey/#generate-a-firebase-server-key", 
            "text": "", 
            "title": "Generate a Firebase Server Key"
        }, 
        {
            "location": "/android/firebasekey/#your-firebase-server-key-and-firebase-sender-id-are-used-to-send-push-notifications-to-android-devices", 
            "text": "To begin, we'll obtain a Firebase Server Key and Firebase Sender ID. These keys allow Kontext to use Google's web push services for your notifications.", 
            "title": "Your Firebase Server Key and Firebase Sender ID are used to send push notifications to ANDROID devices."
        }, 
        {
            "location": "/android/firebasekey/#1-create-a-firebase-project", 
            "text": "1.1  Visit the  Firebase Console  and sign in with your Google account.   1.2 \u00a0Press \"CREATE NEW PROJECT\" or select an existing one below.   1.3 \u00a0Enter a project name and press \"CREATE PROJECT\".", 
            "title": "1. Create a Firebase project"
        }, 
        {
            "location": "/android/firebasekey/#2-getting-your-firebase-cloud-messaging-token-and-sender-id", 
            "text": "2.1  Click the Gear icon in the top left and select \"Project settings\".  2.2  Select the \"CLOUD MESSAGING\" tab.  2.3  Save the two values listed:   You'll need your  Server key  and  Sender ID .", 
            "title": "2. Getting your Firebase Cloud Messaging token and Sender ID"
        }, 
        {
            "location": "/android/firebasekey/#3-configure-your-kontext-apps-android-platform-settings", 
            "text": "3.1  Go to Settings and paste your  Sender ID and FCM credentials .  3.2  Press Save to generate your app ID and key.    Done!!!  You now have a key to send push notifications from your Android app.", 
            "title": "3. Configure your Kontext app's Android platform settings"
        }, 
        {
            "location": "/android/troubleshoot/", 
            "text": "Troubleshooting Android\n\n\nError:Execution failed for task ':app:processDebugGoogleServices'.\n\n\nIf you are receiving the following Android Studio error when building your project\n\n\n1\n2\nError\n:\nExecution\n \nfailed\n \nfor\n \ntask\n \n:app:processDebugGoogleServices\n.\n\n\n \nPlease\n \nfix\n \nthe\n \nversion\n \nconflict\n \neither\n \nby\n \nupdating\n \nthe\n \nversion\n \nof\n \nthe\n \ngoogle\n-\nservices\n \nplugin\n \n(\ninformation\n \nabout\n \nthe\n \nlatest\n \nversion\n \nis\n \navailable\n \nat\n \nhttps\n://\nbintray\n.\ncom\n/android/android-tools/com.google.gms.google-services/\n)\n \nor\n \nupdating\n \nthe\n \nversion\n \nof\n \ncom\n.\ngoogle\n.\nandroid\n.\ngms\n \nto\n \n9.0\n.\n0\n.\n\n\n\n\n\n\n\nRemove the following line from your \n.gradle\n file.\n\n\n1\napply plugin: \ncom.google.gms.google-services\n\n\n\n\n\n\n\nError: Failed to resolve: com.android.support:customtabs:[26.0.0,26.2.0) OR com.android.support:support-v4:[26.0.0,26.2.0)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nFailed to resolve: com.android.support:customtabs:[26.0.0,26.1.0)\nCould not resolve all dependencies for configuration \n:appName:\n.\n   \n Could not find any version that matches com.android.support:customtabs:[26.0.0,26.2.0).\n     Versions that do not match:\n         26.0.0-alpha1\n         25.3.1\n         + 19 more\n     Required by:\n         project :appName \n com.kontext:kontext:3.6.0\n\n\n\n\n\n\n\n\nPlease use one of the Options below to resolve the issue;\n\n\nOption A\n\n\nAdd the new \nGoogle Maven repo\n to your \nbuild.gradle\n\n\n\n\nbuild.gradle\n\n\n\n\n1\n2\n3\nrepositories {\n    maven { url \nhttps://maven.google.com\n }\n}\n\n\n\n\n\n\nAlso update \ncompileSdkVersion\n to \n26\n in your \napp/build.gradle\n.\n\n\nOption B\n\n\nIf you are not ready to update your project to the new support library yet and are still using \ntargetSdkVersion 25\nor lower you can follow Option A or C in the section's instructions.\n\n\nError: All gms/firesbase libraries must use the exact same version specification\n\n\n1\n2\n3\nAll gms/firebase libraries must use the exact same version (mixing versions can lead to runtime crashes).\nFound versions 11.0.4, 10.2.1.\nExamples include com.google.android.gms:play-services-base:11.0.4 and com.google.android.gms:play-services-gcm:10.2.1.\n\n\n\n\n\n\n\n\nKontext automatically adds the following dependencies;\n\n\n\n\ncom.google.android.gms\n - Version 11.2.+\n\n\ncom.android.support\n - Version 26.1.+\n\n\n\n\nTo fix this issue, all dependencies must be matching versions.\n\n\nUpgrade - Find all \ncom.google.android.gms\n compile lines and update them to match.\n\n\n\n\nbuild.gradle\n\n\n\n\n1\n2\n// Update 12.0.1+ so it is using the same gms version as Kontext\ncompile \ncom.google.android.gms:play-services-maps:12.0.1\n\n\n\n\n\n\n\nError: java.lang.NoSuchMethodError: com.google.android.gms.common.internal.zzaa.zzb\n\n\nIf you see that some obfuscated Firebase or Google GMS methods are missing, it is most probably a dependency versioning conflict.\n\n\nYou can use the \ngradle dependencies\n and \ngradle dependencyInsight\n directives to troubleshoot which libraries are causing classes/methods to go missing. Refer to the official Gradle documentation for more information:\n\n\nhttps://docs.gradle.org/current/userguide/tutorial_gradle_command_line.html#sec:dependency_insight\n\n\nFor example:\n\n\n1\n./gradlew app:dependencyInsight --configuration compile\n\n\n\n\n\n\nError:Execution failed for task ':app:processDebugManifest'\n\n\n1\n2\nExecution failed for task \n:app:processDebugManifest\n\nManifest merger failed with multiple errors, see logs \n\n\n\n\n\n\n\n\nERROR: AppId format is invalid\n\n\n\n\n\n\nMake sure you have \nkontext_app_id\n in your \nbuild.gradle\n and your id is correct.\n\n\n\n\n\n\nGradle\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\nandroid {\n   defaultConfig {\n      manifestPlaceholders = [kontext_app_id: \nPUT YOUR KONTEXT APP ID HERE\n,\n                              // Project number pulled from dashboard, local value is ignored.\n                              kontext_google_project_number: \nREMOTE\n]\n    }\n }\n\n\n\n\n\n\n\n\nMake sure you are not replacing the \napplication\n tag in your \nAndroidManifest.xml\n with \ntools\n:\nnode\n=\nreplace\n\n\n\n\n1\n2\n3\n4\napplication\n\n\nandroid:icon=\n@mipmap/ic_launcher\n\n\ntools:node=\nreplace\n \n!--\n \nRemove\n \nthis\n \nline!!!\n \n--\n\nandroid:name=\n.ApplicationClass\n\n\n\n\n\n\n\nIf you must replace some attributes please use \ntools\n:\nreplace\n instead \ntools\n:\nnode\n.\nExample: \ntools\n:\nreplace\n=\nicon, label\n\n\nHow to get a crash or error log from an Android device\n\n\nWith Android Studio\n\n\n1.\n Select \nAndroid Monitor\n from the bottom of the window.\n------If you don't see this select it from \nView\n \n \nTool Windows\n \n \nAndroid Monitor\n\n\n2.\n Select your device from the drop down.\n\n3.\n Ensure no filters are set and the type is set to Verbose.\n\n\n\n\n4.\n\u00a0Select all lines in the log by pressing Control + A and then copy them. \n5.\n\u00a0Paste them into a\u00a0\n.txt\n\u00a0file and send this to support. Include steps to reproduce the problem as well.\n\n\nWith the terminal / command line.\n\n\n1.\n \nadb logcat -b all -d -v threadtime \n kontext_crash_logcat.txt\n\n\n2.\n Send the \nkontext_crash_logcat.txt\n to support. Include steps to reproduce the problem as well.\n\n\nIf you don't have \nadb\n in your path you will need to fully path to \nadb\n in the Android SDK. It is under \nandroid-sdk\n\\platform-tools\\adb\n.\nIf you don't have the Android SDK installed you can just download the \nSDK Platform Tools\n which contains the \nadb\nexecutable.\n\n\nAndroid Studio - No resource found that matches the given name: attr 'android:keyboardNavigationCluster'\n\n\nMake sure you have \ncompileSdkVersion\n to \n26\n in your \napp/build.gradle\n. This is required when you update to 26 of the Android Support Library.\n\n\nEclipse - ERROR - \"conversion to dalvik format failed with error 1\"\n\n\nIf you're getting a \nconversion to dalvik format failed with error 1\n error with \nDx bad class file magic (cafebabe) or version (0033.0000)\n messages before this then you may have the wrong Java version set on your system. See the follow post to fix this as well as the other answers.\n\nhttp://stackoverflow.com/a/9041471/1244574\n\n\n\n\nStill facing issues? We'are happy to help\n\n\nWe answer most support queries in under 4 hours during the week, and under 24 hours on weekends. Simply email us at \n\n    1. Version of our SDK\n    2. Device OS version\n    3. Android crash lock or stack trace of the app         starting and the problem point\n    4. Any other libraries or plugins in your app\n    5. Details on reproducing your problem.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/android/troubleshoot/#troubleshooting-android", 
            "text": "", 
            "title": "Troubleshooting Android"
        }, 
        {
            "location": "/android/troubleshoot/#errorexecution-failed-for-task-appprocessdebuggoogleservices", 
            "text": "If you are receiving the following Android Studio error when building your project  1\n2 Error : Execution   failed   for   task   :app:processDebugGoogleServices .    Please   fix   the   version   conflict   either   by   updating   the   version   of   the   google - services   plugin   ( information   about   the   latest   version   is   available   at   https :// bintray . com /android/android-tools/com.google.gms.google-services/ )   or   updating   the   version   of   com . google . android . gms   to   9.0 . 0 .    Remove the following line from your  .gradle  file.  1 apply plugin:  com.google.gms.google-services", 
            "title": "Error:Execution failed for task ':app:processDebugGoogleServices'."
        }, 
        {
            "location": "/android/troubleshoot/#error-failed-to-resolve-comandroidsupportcustomtabs26002620-or-comandroidsupportsupport-v426002620", 
            "text": "1\n2\n3\n4\n5\n6\n7\n8\n9 Failed to resolve: com.android.support:customtabs:[26.0.0,26.1.0)\nCould not resolve all dependencies for configuration  :appName: .\n     Could not find any version that matches com.android.support:customtabs:[26.0.0,26.2.0).\n     Versions that do not match:\n         26.0.0-alpha1\n         25.3.1\n         + 19 more\n     Required by:\n         project :appName   com.kontext:kontext:3.6.0    Please use one of the Options below to resolve the issue;", 
            "title": "Error: Failed to resolve: com.android.support:customtabs:[26.0.0,26.2.0) OR com.android.support:support-v4:[26.0.0,26.2.0)"
        }, 
        {
            "location": "/android/troubleshoot/#option-a", 
            "text": "Add the new  Google Maven repo  to your  build.gradle   build.gradle   1\n2\n3 repositories {\n    maven { url  https://maven.google.com  }\n}   Also update  compileSdkVersion  to  26  in your  app/build.gradle .", 
            "title": "Option A"
        }, 
        {
            "location": "/android/troubleshoot/#option-b", 
            "text": "If you are not ready to update your project to the new support library yet and are still using  targetSdkVersion 25 or lower you can follow Option A or C in the section's instructions.", 
            "title": "Option B"
        }, 
        {
            "location": "/android/troubleshoot/#error-all-gmsfiresbase-libraries-must-use-the-exact-same-version-specification", 
            "text": "1\n2\n3 All gms/firebase libraries must use the exact same version (mixing versions can lead to runtime crashes).\nFound versions 11.0.4, 10.2.1.\nExamples include com.google.android.gms:play-services-base:11.0.4 and com.google.android.gms:play-services-gcm:10.2.1.    Kontext automatically adds the following dependencies;   com.google.android.gms  - Version 11.2.+  com.android.support  - Version 26.1.+   To fix this issue, all dependencies must be matching versions.  Upgrade - Find all  com.google.android.gms  compile lines and update them to match.   build.gradle   1\n2 // Update 12.0.1+ so it is using the same gms version as Kontext\ncompile  com.google.android.gms:play-services-maps:12.0.1", 
            "title": "Error: All gms/firesbase libraries must use the exact same version specification"
        }, 
        {
            "location": "/android/troubleshoot/#error-javalangnosuchmethoderror-comgoogleandroidgmscommoninternalzzaazzb", 
            "text": "If you see that some obfuscated Firebase or Google GMS methods are missing, it is most probably a dependency versioning conflict.  You can use the  gradle dependencies  and  gradle dependencyInsight  directives to troubleshoot which libraries are causing classes/methods to go missing. Refer to the official Gradle documentation for more information:  https://docs.gradle.org/current/userguide/tutorial_gradle_command_line.html#sec:dependency_insight  For example:  1 ./gradlew app:dependencyInsight --configuration compile   Error:Execution failed for task ':app:processDebugManifest'  1\n2 Execution failed for task  :app:processDebugManifest \nManifest merger failed with multiple errors, see logs", 
            "title": "Error: java.lang.NoSuchMethodError: com.google.android.gms.common.internal.zzaa.zzb"
        }, 
        {
            "location": "/android/troubleshoot/#error-appid-format-is-invalid", 
            "text": "Make sure you have  kontext_app_id  in your  build.gradle  and your id is correct.    Gradle    1\n2\n3\n4\n5\n6\n7 android {\n   defaultConfig {\n      manifestPlaceholders = [kontext_app_id:  PUT YOUR KONTEXT APP ID HERE ,\n                              // Project number pulled from dashboard, local value is ignored.\n                              kontext_google_project_number:  REMOTE ]\n    }\n }    Make sure you are not replacing the  application  tag in your  AndroidManifest.xml  with  tools : node = replace   1\n2\n3\n4 application  android:icon= @mipmap/ic_launcher  tools:node= replace   !--   Remove   this   line!!!   -- \nandroid:name= .ApplicationClass    If you must replace some attributes please use  tools : replace  instead  tools : node .\nExample:  tools : replace = icon, label", 
            "title": "ERROR: AppId format is invalid"
        }, 
        {
            "location": "/android/troubleshoot/#how-to-get-a-crash-or-error-log-from-an-android-device", 
            "text": "", 
            "title": "How to get a crash or error log from an Android device"
        }, 
        {
            "location": "/android/troubleshoot/#with-android-studio", 
            "text": "1.  Select  Android Monitor  from the bottom of the window.\n------If you don't see this select it from  View     Tool Windows     Android Monitor  2.  Select your device from the drop down. 3.  Ensure no filters are set and the type is set to Verbose.   4. \u00a0Select all lines in the log by pressing Control + A and then copy them.  5. \u00a0Paste them into a\u00a0 .txt \u00a0file and send this to support. Include steps to reproduce the problem as well.", 
            "title": "With Android Studio"
        }, 
        {
            "location": "/android/troubleshoot/#with-the-terminal-command-line", 
            "text": "1.   adb logcat -b all -d -v threadtime   kontext_crash_logcat.txt  2.  Send the  kontext_crash_logcat.txt  to support. Include steps to reproduce the problem as well.  If you don't have  adb  in your path you will need to fully path to  adb  in the Android SDK. It is under  android-sdk \\platform-tools\\adb .\nIf you don't have the Android SDK installed you can just download the  SDK Platform Tools  which contains the  adb executable.", 
            "title": "With the terminal / command line."
        }, 
        {
            "location": "/android/troubleshoot/#android-studio-no-resource-found-that-matches-the-given-name-attr-androidkeyboardnavigationcluster", 
            "text": "Make sure you have  compileSdkVersion  to  26  in your  app/build.gradle . This is required when you update to 26 of the Android Support Library.", 
            "title": "Android Studio - No resource found that matches the given name: attr 'android:keyboardNavigationCluster'"
        }, 
        {
            "location": "/android/troubleshoot/#eclipse-error-conversion-to-dalvik-format-failed-with-error-1", 
            "text": "If you're getting a  conversion to dalvik format failed with error 1  error with  Dx bad class file magic (cafebabe) or version (0033.0000)  messages before this then you may have the wrong Java version set on your system. See the follow post to fix this as well as the other answers. http://stackoverflow.com/a/9041471/1244574   Still facing issues? We'are happy to help  We answer most support queries in under 4 hours during the week, and under 24 hours on weekends. Simply email us at  \n    1. Version of our SDK\n    2. Device OS version\n    3. Android crash lock or stack trace of the app         starting and the problem point\n    4. Any other libraries or plugins in your app\n    5. Details on reproducing your problem.", 
            "title": "Eclipse - ERROR - \"conversion to dalvik format failed with error 1\""
        }, 
        {
            "location": "/iOS/quickstart/", 
            "text": "iOS SDK Setup\n\n\n\n\nUpgrade to 2.5.1+\n\n\n\n\n1\n A number the methods and classes below were recently added in our 3.5.1 SDK. Make sure you have updated to this version.\n\n\n\n\n\n\nRequired For Setup\n\n\n\n\nA Kontext Account\n if you do not already have one\n\n\nYour Kontext App ID, available in \nKeys \n IDs\n\n\nAn iOS Push Certificate. \nGenerate one here\n.\n\n\nAn iOS device (iPhone, iPad, iPod Touch) to test on. The Xcode simulator doesn't support push notifications so you must test on a real device.\n\n\nA Mac with a new version of Xcode\n\n\n\n\n1. Download the SDK\n\n\nClick Here to download the SDK\n\n\n2. Add Notification Service Extension\n\n\n2.1\n In Xcode Select \nFile\n \n \nNew\n \n \nTarget...\n\n\n2.2\n Select \nNotification Service Extension\n then press \nNext\n.\n\n\nIMAGE\n\n\n2.3\n\u00a0Enter the product name as\u00a0\nKontextNotificationServiceExtension\n\u00a0and press\u00a0\nFinish\n.\n\n\nIMAGE\n\n\n2.4\n\u00a0Press Cancel on the Activate scheme prompt.\n\n\nIMAGE\n\n\nBy cancelling, you are keeping Xcode debugging your app, instead of just the extension. If you activate by accident, you can always switch back to debug your app within Xcode (next to the play button).\n\n\n2.5\n Open the Xcode project settings and select the KontextNotificationServiceExtension target. Unless you have a specific reason not to, you should set the \nDeployment Target\n to be iOS 10.\n\n\nIMAGE\n\n\n2.6\n\u00a0Open\u00a0\nNotificationService.m\n\u00a0or\u00a0\nNotificationService.swift\n\u00a0and replace the whole file contents with the below code.\n\n\n\n\n\n\nswift\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\nimport\n \nUserNotifications\n\n\n\nimport\n \nKontext\n\n\n\nclass\n \nNotificationService\n:\n \nUNNotificationServiceExtension\n \n{\n\n\n    \nvar\n \ncontentHandler\n:\n \n((\nUNNotificationContent\n)\n \n-\n \nVoid\n)?\n\n    \nvar\n \nreceivedRequest\n:\n \nUNNotificationRequest\n!\n\n    \nvar\n \nbestAttemptContent\n:\n \nUNMutableNotificationContent\n?\n\n\n    \noverride\n \nfunc\n \ndidReceive\n(\n_\n \nrequest\n:\n \nUNNotificationRequest\n,\n \nwithContentHandler\n \ncontentHandler\n:\n \n@\nescaping\n \n(\nUNNotificationContent\n)\n \n-\n \nVoid\n)\n \n{\n\n        \nself\n.\nreceivedRequest\n \n=\n \nrequest\n;\n\n        \nself\n.\ncontentHandler\n \n=\n \ncontentHandler\n\n        \nbestAttemptContent\n \n=\n \n(\nrequest\n.\ncontent\n.\nmutableCopy\n()\n \nas\n?\n \nUNMutableNotificationContent\n)\n\n\n        \nif\n \nlet\n \nbestAttemptContent\n \n=\n \nbestAttemptContent\n \n{\n\n            \nKontext\n.\ndidReceiveNotificationExtensionRequest\n(\nself\n.\nreceivedRequest\n,\n \nwith\n:\n \nself\n.\nbestAttemptContent\n)\n\n            \ncontentHandler\n(\nbestAttemptContent\n)\n\n        \n}\n\n    \n}\n\n\n    \noverride\n \nfunc\n \nserviceExtensionTimeWillExpire\n()\n \n{\n\n        \n// Called just before the extension will be terminated by the system.\n\n        \n// Use this as an opportunity to deliver your \nbest attempt\n at modified content, otherwise the original push payload will be used.\n\n        \nif\n \nlet\n \ncontentHandler\n \n=\n \ncontentHandler\n,\n \nlet\n \nbestAttemptContent\n \n=\n  \nbestAttemptContent\n \n{\n\n            \nKontext\n.\nserviceExtensionTimeWillExpireRequest\n(\nself\n.\nreceivedRequest\n,\n \nwith\n:\n \nself\n.\nbestAttemptContent\n)\n\n            \ncontentHandler\n(\nbestAttemptContent\n)\n\n        \n}\n\n    \n}\n\n\n\n}\n\n\n\n\n\n\n\n\nobjective-c\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n#import \nKontext/Kontext.h\n\n\n\n#import \nNotificationService.h\n\n\n\n@interface\n \nNotificationService\n \n()\n\n\n\n@property\n \n(\nnonatomic\n,\n \nstrong\n)\n \nvoid\n \n(\n^\ncontentHandler\n)(\nUNNotificationContent\n \n*\ncontentToDeliver\n);\n\n\n@property\n \n(\nnonatomic\n,\n \nstrong\n)\n \nUNNotificationRequest\n \n*\nreceivedRequest\n;\n\n\n@property\n \n(\nnonatomic\n,\n \nstrong\n)\n \nUNMutableNotificationContent\n \n*\nbestAttemptContent\n;\n\n\n\n@end\n\n\n\n@implementation\n \nNotificationService\n\n\n\n-\n \n(\nvoid\n)\ndidReceiveNotificationRequest:\n(\nUNNotificationRequest\n \n*\n)\nrequest\n \nwithContentHandler:\n(\nvoid\n \n(\n^\n)(\nUNNotificationContent\n \n*\n \n_Nonnull\n))\ncontentHandler\n \n{\n\n    \nself\n.\nreceivedRequest\n \n=\n \nrequest\n;\n\n    \nself\n.\ncontentHandler\n \n=\n \ncontentHandler\n;\n\n    \nself\n.\nbestAttemptContent\n \n=\n \n[\nrequest\n.\ncontent\n \nmutableCopy\n];\n\n\n    \n[\nKontext\n \ndidReceiveNotificationExtensionRequest\n:\nself\n.\nreceivedRequest\n \nwithMutableNotificationContent\n:\nself\n.\nbestAttemptContent\n];\n\n\n    \n// DEBUGGING: Uncomment the 2 lines below and comment out the one above to ensure this extension is excuting\n\n    \n//            Note, this extension only runs when mutable-content is set\n\n    \n//            Setting an attachment or action buttons automatically adds this\n\n    \n// NSLog(@\nRunning NotificationServiceExtension\n);\n\n    \n// self.bestAttemptContent.body = [@\n[Modified] \n stringByAppendingString:self.bestAttemptContent.body];\n\n\n    \nself\n.\ncontentHandler\n(\nself\n.\nbestAttemptContent\n);\n\n\n}\n\n\n\n-\n \n(\nvoid\n)\nserviceExtensionTimeWillExpire\n \n{\n\n    \n// Called just before the extension will be terminated by the system.\n\n    \n// Use this as an opportunity to deliver your \nbest attempt\n at modified content, otherwise the original push payload will be used.\n\n\n    \n[\nKontext\n \nserviceExtensionTimeWillExpireRequest\n:\nself\n.\nreceivedRequest\n \nwithMutableNotificationContent\n:\nself\n.\nbestAttemptContent\n];\n\n\n    \nself\n.\ncontentHandler\n(\nself\n.\nbestAttemptContent\n);\n\n\n}\n\n\n\n@end\n\n\n\n\n\n\n\n\nIgnore any build errors at this point, step 2 will import Kontext which will resolve any errors.\n\n\n3. Import Kontext into your Xcode project\n\n\nSetup CocoaPods\n on your system if you don't have it already.\n\n\n\n\nMake sure you have version \n1.1.0\n or newer by running \npod --version\n from the terminal.\n\n\nRun the following to upgrade \nsudo gem install cocoapods\n\n\n\n\n3.1\n Make sure your current Xcode project is closed.\n\n\n3.2\n Run \npod init\n from the terminal in your project directory.\n\n\n3.3\n Open the newly created \nPodfile\n with your favorite code editor such as Sublime.\n\n\n3.4\n Add \npod \nKontext\n, \n= 2.5.2\n, \n 3.0\n in your project name target as well as \nKontextNotificationServiceExtension\n.\n\n\n1\n2\n3\n4\n5\n6\n7\ntarget \nproject_name\n do\n  pod \nKontext\n, \n= 2.6.2\n, \n 3.0\n\nend\n\ntarget \nKontextNotificationServiceExtension\n do\n  pod \nKontext\n, \n= 2.6.2\n, \n 3.0\n\nend\n\n\n\n\n\n\n3.5\n\u00a0Run the following from the terminal.\n\n\n1\n2\npod repo update\npod install\n\n\n\n\n\n\n3.6\n\u00a0Open the newly created\u00a0\n.xcworkspace\n\u00a0file. \nMake sure to always open the workspace from now on.\n \n\n\n3.7\n\u00a0Continue to Steps 3 and 4 below\n\n\n4. Add Required Capabilities\n\n\n4.1\n Select the root project and Under Capabilities Enable \"Push Notifications\".\n\n4.2\n Next Enable \"Background Modes\" and check \"Remote notifications\".\n\n\nIMAGE\n\n\n5. Add Required Code\n\n\nAdd following Kontext initialization code to your \nAppDelegate\n.\n\n\n\n\n\n\nswift\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nimport\n \nKontext\n\n\n\nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]?)\n \n-\n \nBool\n \n{\n\n\n   \nlet\n \nkontextInitSettings\n \n=\n \n[\nkontextSettingsKeyAutoPrompt\n:\n \nfalse\n]\n\n\n   \n// Replace \nYOUR_APP_ID\n with your Kontext App ID.\n\n   \nKontext\n.\ninitWithLaunchOptions\n(\nlaunchOptions\n,\n\n       \nappId\n:\n \nYOUR_APP_ID\n,\n\n       \nhandleNotificationAction\n:\n \nnil\n,\n\n       \nsettings\n:\n \nkontextInitSettings\n)\n\n\n   \nKontext\n.\ninFocusDisplayType\n \n=\n \nKontextNotificationDisplayType\n.\nnotification\n;\n\n\n   \n// Recommend moving the below line to prompt for push after informing the user about\n\n   \n//   how your app will use them.\n\n   \nKontext\n.\npromptForPushNotifications\n(\nuserResponse\n:\n \n{\n \naccepted\n \nin\n\n      \nprint\n(\nUser accepted notifications: \n\\(\naccepted\n)\n)\n\n   \n})\n\n\n   \nreturn\n \ntrue\n\n\n}\n\n\n\n\n\n\n\n\nobjective-c\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n#import \nKontext/Kontext.h\n\n\n\n@implementation\n \nAppDelegate\n\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n \n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n \n{\n\n\n   \n// Replace \n11111111-2222-3333-4444-0123456789ab\n with your Kontext App ID.\n\n   \n[\nKontext\n \ninitWithLaunchOptions\n:\nlaunchOptions\n\n                              \nappId\n:\n@\n11111111-2222-3333-4444-0123456789ab\n\n                 \nhandleNotificationAction\n:\nnil\n\n                            \nsettings\n:\n@{\nkontextSettingsKeyAutoPrompt\n:\n \n@\nfalse\n}\n];\n\n   \nKontext\n.\ninFocusDisplayType\n \n=\n \nKontextNotificationDisplayTypeNotification\n;\n\n\n   \n// Recommend moving the below line to prompt for push after informing the user about\n\n   \n//   how your app will use them.\n\n   \n[\nKontext\n \npromptForPushNotificationsWithUserResponse\n:\n^\n(\nBOOL\n \naccepted\n)\n \n{\n\n        \nNSLog\n(\n@\nUser accepted notifications: %d\n,\n \naccepted\n);\n\n   \n}];\n\n\n   \nreturn\n \nYES\n;\n\n\n}\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n1\nKontext `initWithLaunchOptions`\u00a0must be called from your\u00a0`didFinishLaunchingWithOptions`, as in the example above.\n\n\n\n\n\n\n\n\nTroubleshooting\n\n\n\n\n1\nIf run into any issues please see our [iOS troubleshooting guide](/iOS/troubleshoot).\n\n\n\n\n\n\n6. Add Email\n\n\nRECOMMENDED\n\n\nNext, if you collect emails from users, you can set a user's email with the \nsetEmail\n method. This enables Kontext Email Messaging, which allows you to send emails in addition to push.\n\n\n\n\n\n\nswift\n\n\n1\nKontext\n.\nsetEmail\n(\nexample@domain.com\n);\n\n\n\n\n\n\n\n\nobjective-c\n\n\n1\n[\nKontext\n \nsetEmail\n:\n@\nexample@domain.com\n];\n\n\n\n\n\n\n\n\n7. Add App Groups (Optional but Recommended)\n\n\nIn order for your application to be able to let push notifications increment/decrement the badge count, you need to set up an\u00a0\nApp Group\n\u00a0for your application.\n\n\nCallbacks\n\n\nKontextHandleNotificationReceivedBlock\n - Called when a notification is received while your app is in focus only.\n\nKontextHandleNotificationActionBlock\n - This will be called when a notification is tapped on.\nSee our \ninitWithLaunchOptions\n documentation to add these.\n\n\n\n\nYou're Done!\n\n\n\n\n1\nNext\n \nup\n:\n \nSend\n \nyour\n \nfirst\n \npush\n \nnotification\n \nvia\n \nthe\n \n[\nKontext\n \nDashboard\n](\nhttps\n:\n//app.kontext.in)", 
            "title": "Quick Start"
        }, 
        {
            "location": "/iOS/quickstart/#ios-sdk-setup", 
            "text": "Upgrade to 2.5.1+   1  A number the methods and classes below were recently added in our 3.5.1 SDK. Make sure you have updated to this version.", 
            "title": "iOS SDK Setup"
        }, 
        {
            "location": "/iOS/quickstart/#required-for-setup", 
            "text": "A Kontext Account  if you do not already have one  Your Kontext App ID, available in  Keys   IDs  An iOS Push Certificate.  Generate one here .  An iOS device (iPhone, iPad, iPod Touch) to test on. The Xcode simulator doesn't support push notifications so you must test on a real device.  A Mac with a new version of Xcode", 
            "title": "Required For Setup"
        }, 
        {
            "location": "/iOS/quickstart/#1-download-the-sdk", 
            "text": "Click Here to download the SDK", 
            "title": "1. Download the SDK"
        }, 
        {
            "location": "/iOS/quickstart/#2-add-notification-service-extension", 
            "text": "2.1  In Xcode Select  File     New     Target...  2.2  Select  Notification Service Extension  then press  Next .", 
            "title": "2. Add Notification Service Extension"
        }, 
        {
            "location": "/iOS/quickstart/#image", 
            "text": "2.3 \u00a0Enter the product name as\u00a0 KontextNotificationServiceExtension \u00a0and press\u00a0 Finish .", 
            "title": "IMAGE"
        }, 
        {
            "location": "/iOS/quickstart/#image_1", 
            "text": "2.4 \u00a0Press Cancel on the Activate scheme prompt.", 
            "title": "IMAGE"
        }, 
        {
            "location": "/iOS/quickstart/#image_2", 
            "text": "By cancelling, you are keeping Xcode debugging your app, instead of just the extension. If you activate by accident, you can always switch back to debug your app within Xcode (next to the play button).  2.5  Open the Xcode project settings and select the KontextNotificationServiceExtension target. Unless you have a specific reason not to, you should set the  Deployment Target  to be iOS 10.", 
            "title": "IMAGE"
        }, 
        {
            "location": "/iOS/quickstart/#image_3", 
            "text": "2.6 \u00a0Open\u00a0 NotificationService.m \u00a0or\u00a0 NotificationService.swift \u00a0and replace the whole file contents with the below code.    swift   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31 import   UserNotifications  import   Kontext  class   NotificationService :   UNNotificationServiceExtension   { \n\n     var   contentHandler :   (( UNNotificationContent )   -   Void )? \n     var   receivedRequest :   UNNotificationRequest ! \n     var   bestAttemptContent :   UNMutableNotificationContent ? \n\n     override   func   didReceive ( _   request :   UNNotificationRequest ,   withContentHandler   contentHandler :   @ escaping   ( UNNotificationContent )   -   Void )   { \n         self . receivedRequest   =   request ; \n         self . contentHandler   =   contentHandler \n         bestAttemptContent   =   ( request . content . mutableCopy ()   as ?   UNMutableNotificationContent ) \n\n         if   let   bestAttemptContent   =   bestAttemptContent   { \n             Kontext . didReceiveNotificationExtensionRequest ( self . receivedRequest ,   with :   self . bestAttemptContent ) \n             contentHandler ( bestAttemptContent ) \n         } \n     } \n\n     override   func   serviceExtensionTimeWillExpire ()   { \n         // Called just before the extension will be terminated by the system. \n         // Use this as an opportunity to deliver your  best attempt  at modified content, otherwise the original push payload will be used. \n         if   let   contentHandler   =   contentHandler ,   let   bestAttemptContent   =    bestAttemptContent   { \n             Kontext . serviceExtensionTimeWillExpireRequest ( self . receivedRequest ,   with :   self . bestAttemptContent ) \n             contentHandler ( bestAttemptContent ) \n         } \n     }  }     objective-c   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40 #import  Kontext/Kontext.h  #import  NotificationService.h  @interface   NotificationService   ()  @property   ( nonatomic ,   strong )   void   ( ^ contentHandler )( UNNotificationContent   * contentToDeliver );  @property   ( nonatomic ,   strong )   UNNotificationRequest   * receivedRequest ;  @property   ( nonatomic ,   strong )   UNMutableNotificationContent   * bestAttemptContent ;  @end  @implementation   NotificationService  -   ( void ) didReceiveNotificationRequest: ( UNNotificationRequest   * ) request   withContentHandler: ( void   ( ^ )( UNNotificationContent   *   _Nonnull )) contentHandler   { \n     self . receivedRequest   =   request ; \n     self . contentHandler   =   contentHandler ; \n     self . bestAttemptContent   =   [ request . content   mutableCopy ]; \n\n     [ Kontext   didReceiveNotificationExtensionRequest : self . receivedRequest   withMutableNotificationContent : self . bestAttemptContent ]; \n\n     // DEBUGGING: Uncomment the 2 lines below and comment out the one above to ensure this extension is excuting \n     //            Note, this extension only runs when mutable-content is set \n     //            Setting an attachment or action buttons automatically adds this \n     // NSLog(@ Running NotificationServiceExtension ); \n     // self.bestAttemptContent.body = [@ [Modified]   stringByAppendingString:self.bestAttemptContent.body]; \n\n     self . contentHandler ( self . bestAttemptContent );  }  -   ( void ) serviceExtensionTimeWillExpire   { \n     // Called just before the extension will be terminated by the system. \n     // Use this as an opportunity to deliver your  best attempt  at modified content, otherwise the original push payload will be used. \n\n     [ Kontext   serviceExtensionTimeWillExpireRequest : self . receivedRequest   withMutableNotificationContent : self . bestAttemptContent ]; \n\n     self . contentHandler ( self . bestAttemptContent );  }  @end     Ignore any build errors at this point, step 2 will import Kontext which will resolve any errors.", 
            "title": "IMAGE"
        }, 
        {
            "location": "/iOS/quickstart/#3-import-kontext-into-your-xcode-project", 
            "text": "Setup CocoaPods  on your system if you don't have it already.   Make sure you have version  1.1.0  or newer by running  pod --version  from the terminal.  Run the following to upgrade  sudo gem install cocoapods   3.1  Make sure your current Xcode project is closed.  3.2  Run  pod init  from the terminal in your project directory.  3.3  Open the newly created  Podfile  with your favorite code editor such as Sublime.  3.4  Add  pod  Kontext ,  = 2.5.2 ,   3.0  in your project name target as well as  KontextNotificationServiceExtension .  1\n2\n3\n4\n5\n6\n7 target  project_name  do\n  pod  Kontext ,  = 2.6.2 ,   3.0 \nend\n\ntarget  KontextNotificationServiceExtension  do\n  pod  Kontext ,  = 2.6.2 ,   3.0 \nend   3.5 \u00a0Run the following from the terminal.  1\n2 pod repo update\npod install   3.6 \u00a0Open the newly created\u00a0 .xcworkspace \u00a0file.  Make sure to always open the workspace from now on.    3.7 \u00a0Continue to Steps 3 and 4 below", 
            "title": "3. Import Kontext into your Xcode project"
        }, 
        {
            "location": "/iOS/quickstart/#4-add-required-capabilities", 
            "text": "4.1  Select the root project and Under Capabilities Enable \"Push Notifications\". 4.2  Next Enable \"Background Modes\" and check \"Remote notifications\".", 
            "title": "4. Add Required Capabilities"
        }, 
        {
            "location": "/iOS/quickstart/#image_4", 
            "text": "", 
            "title": "IMAGE"
        }, 
        {
            "location": "/iOS/quickstart/#5-add-required-code", 
            "text": "Add following Kontext initialization code to your  AppDelegate .    swift   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22 import   Kontext  func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ]?)   -   Bool   { \n\n    let   kontextInitSettings   =   [ kontextSettingsKeyAutoPrompt :   false ] \n\n    // Replace  YOUR_APP_ID  with your Kontext App ID. \n    Kontext . initWithLaunchOptions ( launchOptions , \n        appId :   YOUR_APP_ID , \n        handleNotificationAction :   nil , \n        settings :   kontextInitSettings ) \n\n    Kontext . inFocusDisplayType   =   KontextNotificationDisplayType . notification ; \n\n    // Recommend moving the below line to prompt for push after informing the user about \n    //   how your app will use them. \n    Kontext . promptForPushNotifications ( userResponse :   {   accepted   in \n       print ( User accepted notifications:  \\( accepted ) ) \n    }) \n\n    return   true  }     objective-c   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 #import  Kontext/Kontext.h  @implementation   AppDelegate  -   ( BOOL ) application: ( UIApplication   * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions   { \n\n    // Replace  11111111-2222-3333-4444-0123456789ab  with your Kontext App ID. \n    [ Kontext   initWithLaunchOptions : launchOptions \n                               appId : @ 11111111-2222-3333-4444-0123456789ab \n                  handleNotificationAction : nil \n                             settings : @{ kontextSettingsKeyAutoPrompt :   @ false } ]; \n    Kontext . inFocusDisplayType   =   KontextNotificationDisplayTypeNotification ; \n\n    // Recommend moving the below line to prompt for push after informing the user about \n    //   how your app will use them. \n    [ Kontext   promptForPushNotificationsWithUserResponse : ^ ( BOOL   accepted )   { \n         NSLog ( @ User accepted notifications: %d ,   accepted ); \n    }]; \n\n    return   YES ;  }      Note   1 Kontext `initWithLaunchOptions`\u00a0must be called from your\u00a0`didFinishLaunchingWithOptions`, as in the example above.    Troubleshooting   1 If run into any issues please see our [iOS troubleshooting guide](/iOS/troubleshoot).", 
            "title": "5. Add Required Code"
        }, 
        {
            "location": "/iOS/quickstart/#6-add-email", 
            "text": "RECOMMENDED  Next, if you collect emails from users, you can set a user's email with the  setEmail  method. This enables Kontext Email Messaging, which allows you to send emails in addition to push.    swift  1 Kontext . setEmail ( example@domain.com );     objective-c  1 [ Kontext   setEmail : @ example@domain.com ];", 
            "title": "6. Add Email"
        }, 
        {
            "location": "/iOS/quickstart/#7-add-app-groups-optional-but-recommended", 
            "text": "In order for your application to be able to let push notifications increment/decrement the badge count, you need to set up an\u00a0 App Group \u00a0for your application.", 
            "title": "7. Add App Groups (Optional but Recommended)"
        }, 
        {
            "location": "/iOS/quickstart/#callbacks", 
            "text": "KontextHandleNotificationReceivedBlock  - Called when a notification is received while your app is in focus only. KontextHandleNotificationActionBlock  - This will be called when a notification is tapped on.\nSee our  initWithLaunchOptions  documentation to add these.   You're Done!   1 Next   up :   Send   your   first   push   notification   via   the   [ Kontext   Dashboard ]( https : //app.kontext.in)", 
            "title": "Callbacks"
        }, 
        {
            "location": "/iOS/reference/", 
            "text": "iOS Native SDK\n\n\nKontext iOS Native SDK Reference\n\n\n\n\nJust starting with iOS?\n\n\nCheck out our\u00a0\niOS SDK Setup\n guide.\n\n\n\n\n\n\nUpgrade to 2.5.1+\n\n\nA number the methods and classes below were recently added in our 3.5.1 SDK. Make sure you have updated to this version.\n\n\n\n\nFor Developers\n\n\n\n\n\n\n\n\nCalls\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nInitialization\n\n\n\n\n\n\n\n\n\n\ninitWithLaunchOptions\n\n\nMethod\n\n\nInitialize Kontext\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPrivacy\n\n\n\n\n\n\n\n\n\n\nsetRequiresUserPrivacyConsent\n\n\nMothod\n\n\n\n\n\n\n\n\nconsentGranted\n\n\nMothod\n\n\n\n\n\n\n\n\nrequiresUserPrivacyConsent\n\n\nboolean\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSettings\n\n\n\n\n\n\n\n\n\n\nKontextSettingsKeyAutoPrompt\n\n\nkey\n\n\n\n\n\n\n\n\nKontextSettingsKeyInAppLaunchURL\n\n\nkey\n\n\n\n\n\n\n\n\ninFocusDisplayType\n\n\nProperty\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPrompting\n\n\n\n\n\n\n\n\n\n\npromptForPushNotificationsWithUserResponse\n\n\nMethod\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatus\n\n\n\n\n\n\n\n\n\n\ngetPermissionSubscriptionState\n\n\nMethod\n\n\n\n\n\n\n\n\naddPermissionObserver\n\n\nMethod\n\n\n\n\n\n\n\n\naddSubscriptionObserver\n\n\nMethod\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEvents\n\n\n\n\n\n\n\n\n\n\nsendEvent\n\n\nMethod\n\n\n\n\n\n\n\n\nsendEvents\n\n\nMethod\n\n\n\n\n\n\n\n\nsendScreen\n\n\nMethod\n\n\n\n\n\n\n\n\nsendUserAttributes\n\n\nMethod\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nData\n\n\n\n\n\n\n\n\n\n\nsetLocationShared\n\n\nMethod\n\n\n\n\n\n\n\n\npromptLocation\n\n\nMethod\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSending Notifications\n\n\n\n\n\n\n\n\n\n\npostNotification\n\n\nMethod\n\n\n\n\n\n\n\n\nclearKontextNotifications\n\n\nMethod\n\n\n\n\n\n\n\n\nsetSubscription\n\n\nMethod\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEmail\n\n\n\n\n\n\n\n\n\n\nsetEmail\n\n\nMethod\n\n\n\n\n\n\n\n\nlogoutEmail\n\n\nMethod\n\n\n\n\n\n\n\n\naddEmailSubscriptionObserver\n\n\nMethod\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotification Events\n\n\n\n\n\n\n\n\n\n\nhandleNotificationReceived\n\n\nMethod\n\n\n\n\n\n\n\n\nhandleNotificationAction\n\n\nMethod\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nObjects\n\n\n\n\n\n\n\n\n\n\nKontextNotificationOpenedResult\n\n\nObject\n\n\n\n\n\n\n\n\nKontextNotification\n\n\nObject\n\n\n\n\n\n\n\n\nKontextNotificationAction\n\n\nObject\n\n\n\n\n\n\n\n\nKontextNotificationActionType\n\n\nObject\n\n\n\n\n\n\n\n\nKontextNotificationDisplayType\n\n\nObject\n\n\n\n\n\n\n\n\nKontextNotificationPayload\n\n\nObject\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDebug\n\n\n\n\n\n\n\n\n\n\nsetLogLevel\n\n\nMothod\n\n\n\n\n\n\n\n\n\n\nInitialization\n\n\ninitWithLaunchOptions\n\n\nMETHOD\n\n\nMust be called from \ndidFinishLaunchingWithOptions\n in \nAppDelegate.m\n.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlaunchOptions\n\n\nNSDictionary*\n\n\nREQUIRED\u00a0launchOptions that you received from\u00a0\ndidFinishLaunchingWithOptions\n\n\n\n\n\n\nappId\n\n\nNSString*\n\n\nREQUIRED\u00a0Your Kontext app id, available in\u00a0\nKeys \n IDs\n\n\n\n\n\n\ncallback\n\n\nKontextHandleNotificationReceivedBlock\n\n\nFunction to be called when a notification is received\n\n\n\n\n\n\ncallback\n\n\nKontextHandleNotificationActionBlock\n\n\nFunction to be called when a user reacts to a notification received\n\n\n\n\n\n\nsettings\n\n\nNSDictionary*\n\n\nCustomization settings to change Kontext's default behavior\n\n\n\n\n\n\n\n\n\n\niOS 8+ Notes\n\n\n\n\n\n\napplication\n:\ndidRegisterForRemoteNotificationsWithDeviceToken\n:\n will still fire even if KontextSettingsKeyAutoPrompt is set to false.\n\n\n\n\n\n\nReplace any of your \nisRegisteredForRemoteNotifications\n calls with \ncurrentUserNotificationSettings\n or getPermissionSubscriptionState.\n\n\n\n\n\n\n\n\niOS 8+ Notes\n\n\n\n\napplication\n:\ndidRegisterForRemoteNotificationsWithDeviceToken\n:\n will still fire even if \nKontextSettingsKeyAutoPrompt\n is set to \nfalse\n.\n\n\nReplace any of your \nisRegisteredForRemoteNotifications\n calls with \ncurrentUserNotificationSettings\n or \ngetPermissionSubscriptionState\n.\n\n\n\n\n\n\n\n\nSwift\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]?)\n \n-\n \nBool\n \n{\n\n\n   \nlet\n \nnotificationReceivedBlock\n:\n \nOSHandleNotificationReceivedBlock\n \n=\n \n{\n \nnotification\n \nin\n\n\n      \nprint\n(\nReceived Notification: \n\\(\nnotification\n!.\npayload\n.\nnotificationID\n)\n)\n\n   \n}\n\n\n   \nlet\n \nnotificationOpenedBlock\n:\n \nOSHandleNotificationActionBlock\n \n=\n \n{\n \nresult\n \nin\n\n      \n// This block gets called when the user reacts to a notification received\n\n      \nlet\n \npayload\n:\n \nOSNotificationPayload\n \n=\n \nresult\n!.\nnotification\n.\npayload\n\n\n      \nvar\n \nfullMessage\n \n=\n \npayload\n.\nbody\n\n      \nprint\n(\nMessage = \n\\(\nfullMessage\n)\n)\n\n\n      \nif\n \npayload\n.\nadditionalData\n \n!=\n \nnil\n \n{\n\n         \nif\n \npayload\n.\ntitle\n \n!=\n \nnil\n \n{\n\n            \nlet\n \nmessageTitle\n \n=\n \npayload\n.\ntitle\n\n               \nprint\n(\nMessage Title = \n\\(\nmessageTitle\n!\n)\n)\n\n         \n}\n\n\n         \nlet\n \nadditionalData\n \n=\n \npayload\n.\nadditionalData\n\n         \nif\n \nadditionalData\n?[\nactionSelected\n]\n \n!=\n \nnil\n \n{\n\n            \nfullMessage\n \n=\n \nfullMessage\n!\n \n+\n \n\\n\nPressed ButtonID: \n\\(\nadditionalData\n![\nactionSelected\n]\n)\n\n         \n}\n\n      \n}\n\n   \n}\n\n\n   \nlet\n \nonesignalInitSettings\n \n=\n \n[\nkOSSettingsKeyAutoPrompt\n:\n \nfalse\n,\n\n      \nkOSSettingsKeyInAppLaunchURL\n:\n \ntrue\n]\n\n\n   \nKontext\n.\ninitWithLaunchOptions\n(\nlaunchOptions\n,\n \n      \nappId\n:\n \nYOUR_KONTEXT_APP_ID\n,\n \n      \nhandleNotificationReceived\n:\n \nnotificationReceivedBlock\n,\n \n      \nhandleNotificationAction\n:\n \nnotificationOpenedBlock\n,\n \n      \nsettings\n:\n \nonesignalInitSettings\n)\n\n\n   \nKontext\n.\ninFocusDisplayType\n \n=\n \nOSNotificationDisplayType\n.\nnotification\n\n\n   \nreturn\n \ntrue\n\n\n}\n\n\n\n\n\n\n\n\nObjective-C\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n*\n)\nlaunchOptions\n \n{\n\n\n  \nid\n \nnotificationReceiverBlock\n \n=\n \n^\n(\nOSNotification\n \n*\nnotification\n)\n \n{\n\n    \nNSLog\n(\n@\nReceived Notification - %@\n,\n \nnotification\n.\npayload\n.\nnotificationID\n);\n\n  \n};\n\n\n  \nid\n \nnotificationOpenedBlock\n \n=\n \n^\n(\nOSNotificationOpenedResult\n \n*\nresult\n)\n \n{\n\n        \n// This block gets called when the user reacts to a notification received\n\n        \nOSNotificationPayload\n*\n \npayload\n \n=\n \nresult\n.\nnotification\n.\npayload\n;\n\n\n        \nNSString\n*\n \nmessageTitle\n \n=\n \n@\nKontext Example\n;\n\n        \nNSString\n*\n \nfullMessage\n \n=\n \n[\npayload\n.\nbody\n \ncopy\n];\n\n\n        \nif\n \n(\npayload\n.\nadditionalData\n)\n \n{\n\n\n            \nif\n(\npayload\n.\ntitle\n)\n\n                \nmessageTitle\n \n=\n \npayload\n.\ntitle\n;\n\n\n            \nNSDictionary\n*\n \nadditionalData\n \n=\n \npayload\n.\nadditionalData\n;\n\n\n            \nif\n \n(\nadditionalData\n[\n@\nactionSelected\n])\n\n                \nfullMessage\n \n=\n \n[\nfullMessage\n \nstringByAppendingString\n:[\nNSString\n \nstringWithFormat\n:\n@\n\\n\nPressed ButtonId:%@\n,\n \nadditionalData\n[\n@\nactionSelected\n]]];\n\n        \n}\n\n\n        \nUIAlertView\n*\n \nalertView\n \n=\n \n[[\nUIAlertView\n \nalloc\n]\n \ninitWithTitle\n:\nmessageTitle\n\n                                                            \nmessage\n:\nfullMessage\n\n                                                           \ndelegate\n:\nself\n\n                                                  \ncancelButtonTitle\n:\n@\nClose\n\n                                                  \notherButtonTitles\n:\nnil\n,\n \nnil\n];\n\n        \n[\nalertView\n \nshow\n];\n\n\n   \n};\n\n\n   \nid\n \nonesignalInitSettings\n \n=\n \n@{\nkOSSettingsKeyAutoPrompt\n \n:\n \n@YES\n}\n;\n\n\n   \n[\nKontext\n \ninitWithLaunchOptions\n:\nlaunchOptions\n\n                              \nappId\n:\n@\nYOUR_KONTEXT_APP_ID\n\n         \nhandleNotificationReceived\n:\nnotificationReceiverBlock\n\n           \nhandleNotificationAction\n:\nnotificationOpenedBlock\n\n                           \nsettings\n:\nonesignalInitSettings\n];\n\n\n\n}\n\n\n\n\n\n\n\n\nPrivacy\n\n\nsetRequiresUserPrivacyConsent\n\n\nMETHOD\n\n\nFor GDPR users, your application should call this method \nbefore\n initialization of the SDK. If you pass in \ntrue\n, your application will need to call \nprovideConsent(true)\n before the Kontext SDK gets fully initialized. Until this happens, you can continue to call methods (such as \nsendEvents()\n), but nothing will happen.\n\n\n\n\n\n\nSwift\n\n\n1\n2\n3\n4\n//to require the user\ns consent before the SDK initializes\n\n\nKontext\n.\nsetRequiresUserPrivacyConsent\n(\ntrue\n);\n\n\n\nKontext\n.\ninitWithLaunchOptions\n(\nlaunchOptions\n,\n \nappId\n:\n \nYOUR_KONTEXT_APP_ID\n);\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n2\n3\n4\n//to require the user\ns consent before the SDK initializes\n\n\n[\nKontext\n \nsetRequiresUserPrivacyConsent\n:\ntrue\n];\n\n\n\n[\nKontext\n \ninitWithLaunchOptions\n:\nlaunchOptions\n \nappId\n:\n@\nYOUR_KONTEXT_APP_ID\n];\n\n\n\n\n\n\n\n\nconsentGranted\n\n\nMETHOD\n\n\nIf you set the SDK to require the user's privacy consent, your application can use this method once the user does or doesn't provide privacy consent to use the Kontext SDK.\n\n\n\n\n\n\nSwift\n\n\n1\n2\n3\n4\n@IBAction\n \nfunc\n \nuserTappedProvideConsentButton\n(\n_\n \nsender\n \n:\n \nUIButton\n)\n \n{\n\n  \n//this will complete the initialization of the SDK\n\n    \nKontext\n.\nprovideConsent\n(\ntrue\n);\n \n\n}\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n2\n3\n4\n-\n \n(\nIBAction\n)\nsetEmailButtonPressed:\n(\nUIButton\n \n*\n)\nsender\n \n{\n\n  \n//this will complete the initialization of the SDK\n\n  \n[\nKontext\n \nprovideConsent\n:\ntrue\n];\n\n\n}\n\n\n\n\n\n\n\n\nrequiresUserPrivacyConsent\n\n\nBOOLEAN\n\n\nYou can use this property to check if the Kontext SDK is waiting for the user to provide privacy consent.\n\n\ntrue\n - Indicates that the Kontext SDK hasn't received the user's privacy consent yet\n\nfalse\n - Either the user has already provided consent, or your app isn't set to require consent.\n\n\nSettings\n\n\nkontextSettingsKeyAutoPrompt\n\n\nKEY\n\n\ntrue\n (DEFAULT) - automatically prompts for notifications permissions.\n\nfalse\n - disables auto prompt.\n\n\nkontextSettingsKeyInAppLaunchURL\n\n\nKEY\n\n\ntrue\n (DEFAULT) - Open all URLs with a in-app WebView window.\n\nfalse\n - Launches Safari with the URL OR other app (if deep linked or custom URL scheme passed).\n\n\ninFocusDisplayType\n\n\nPROPERTY\n\n\nSetting to control how Kontext notifications will be shown when one is received while your app is in focus, for apps targeting.\n\n\nKontextNotificationDisplayTypeNotification\n - Native notification display\n\nKontextNotificationDisplayTypeInAppAlert\n (DEFAULT) - Alert dialog display.\n\nKontextNotificationDisplayTypeNone\n - Notification is silent and not shown\n\n\nSwift format:\n\n\nKontextNotificationDisplayType.notification\n\n\nKontextNotificationDisplayType.inAppAlert\n\n\nKontextNotificationDisplayType.none\n\n\n\n\n\n\nSwift\n\n\n1\nKontext\n.\ninFocusDisplayType\n \n=\n \nOSNotificationDisplayType\n.\nnotification\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\nKontext\n.\ninFocusDisplayType\n \n=\n \nOSNotificationDisplayTypeNotification\n;\n\n\n\n\n\n\n\n\n\n\niOS 9 and below\n\n\nThe Notification setting will fall back to InAppAlert .\n\n\n\n\nRegistering Push\n\n\npromptForPushNotificationsWithUserResponse\n\n\nMETHOD\n\n\nPrompt the user for notification permissions. Callback fires as soon as the user accepts or declines notifications.\n\n\nRequirements\n\n\nMust set \nkontextSettingsKeyAutoPrompt\n to \nfalse\n when calling \ninitWithLaunchOptions\n.\n\n\nRecommendations\n\n\nYou can only prompt once so it is recommend to explain what benefits notifications will give the user.\n\n\nExample\n\n\n\n\n\n\nSwift\n\n\n1\n2\n3\n4\n5\n// Call when you want to prompt the user to accept push notifications. \n\n\n// Only call once and only if you set kOSSettingsKeyAutoPrompt in AppDelegate to false.\n\n\nKontext\n.\npromptForPushNotifications\n(\nuserResponse\n:\n \n{\n \naccepted\n \nin\n\n   \nprint\n(\nUser accepted notifications: \n\\(\naccepted\n)\n)\n\n\n})\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n2\n3\n[\nKontext\n \npromptForPushNotificationsWithUserResponse\n:\n^\n(\nBOOL\n \naccepted\n)\n \n{\n\n  \nNSLog\n(\n@\nAccepted Notifications?: %d\n,\n \naccepted\n);\n\n\n}];\n\n\n\n\n\n\n\n\nStatus\n\n\ngetPermissionSubscriptionState\n\n\nMETHOD\n\n\nGet the current notification and permission state. Returns a \nKontextPermissionSubscriptionState\n type described below.\n\n\nKontextPermissionSubscriptionState\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npermissionStatus\n\n\nKontextPermissionState*\n\n\niKontext Notification Permissions state\n\n\n\n\n\n\nsubscriptionStatus\n\n\nKontextSubscriptionState*\n\n\nApple and Kontext subscription state\n\n\n\n\n\n\n\n\n\n\n\n\nSwift\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nlet\n \nstatus\n:\n \nOSPermissionSubscriptionState\n \n=\n \nKontext\n.\ngetPermissionSubscriptionState\n()\n\n\n\nlet\n \nhasPrompted\n \n=\n \nstatus\n.\npermissionStatus\n.\nhasPrompted\n\n\nprint\n(\nhasPrompted = \n\\(\nhasPrompted\n)\n)\n\n\nlet\n \nuserStatus\n \n=\n \nstatus\n.\npermissionStatus\n.\nstatus\n\n\nprint\n(\nuserStatus = \n\\(\nuserStatus\n)\n)\n\n\n\nlet\n \nisSubscribed\n \n=\n \nstatus\n.\nsubscriptionStatus\n.\nsubscribed\n\n\nprint\n(\nisSubscribed = \n\\(\nisSubscribed\n)\n)\n\n\nlet\n \nuserSubscriptionSetting\n \n=\n \nstatus\n.\nsubscriptionStatus\n.\nuserSubscriptionSetting\n\n\nprint\n(\nuserSubscriptionSetting = \n\\(\nuserSubscriptionSetting\n)\n)\n\n\nlet\n \nuserID\n \n=\n \nstatus\n.\nsubscriptionStatus\n.\nuserId\n\n\nprint\n(\nuserID = \n\\(\nuserID\n)\n)\n\n\nlet\n \npushToken\n \n=\n \nstatus\n.\nsubscriptionStatus\n.\npushToken\n\n\nprint\n(\npushToken = \n\\(\npushToken\n)\n)\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nOSPermissionSubscriptionState\n*\n \nstatus\n \n=\n \n[\nKontext\n \ngetPermissionSubscriptionState\n];\n\n\nstatus\n.\npermissionStatus\n.\nhasPrompted\n;\n\n\nstatus\n.\npermissionStatus\n.\nstatus\n;\n\n\n\nstatus\n.\nsubscriptionStatus\n.\nsubscribed\n;\n\n\nstatus\n.\nsubscriptionStatus\n.\nuserSubscriptionSetting\n;\n\n\nstatus\n.\nsubscriptionStatus\n.\nuserId\n;\n\n\nstatus\n.\nsubscriptionStatus\n.\npushToken\n;\n\n\n\n\n\n\n\n\naddPermissionObserver\n\n\nMETHOD\n\n\nThe \nonKontextPermissionChanged\n method will be fired on the passed in object when a notification permission setting changes.\nThis includes the following events: \n\n\n\n\nNotification permission prompt shown\n\n\nThe user accepting or declining the permission prompt\n\n\nEnabling/disabling notifications for your app in the iKontext Settings after returning to your app.\n\n\n\n\nExample\n\n\nExample of setting up with your AppDelegate.\nOutput is showings the user accepting the notification permission prompt.\n\n\n\n\n\n\nSwift\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n// AppDelegate.swift\n\n\n// Add OSPermissionObserver after UIApplicationDelegate\n\n\nclass\n \nAppDelegate\n:\n \nUIResponder\n,\n \nUIApplicationDelegate\n,\n \nOSPermissionObserver\n \n{\n\n\n   \nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]?)\n \n-\n \nBool\n \n{\n\n      \n// Add your AppDelegate as an obsserver\n\n      \nKontext\n.\nadd\n(\nself\n \nas\n \nOSPermissionObserver\n)\n\n   \n}\n\n\n   \n// Add this new method\n\n   \nfunc\n \nonOSPermissionChanged\n(\n_\n \nstateChanges\n:\n \nOSPermissionStateChanges\n!)\n \n{\n\n      \n// Example of detecting answering the permission prompt\n\n      \nif\n \nstateChanges\n.\nfrom\n.\nstatus\n \n==\n \nOSNotificationPermission\n.\nnotDetermined\n \n{\n\n         \nif\n \nstateChanges\n.\nto\n.\nstatus\n \n==\n \nOSNotificationPermission\n.\nauthorized\n \n{\n\n            \nprint\n(\nThanks for accepting notifications!\n)\n\n         \n}\n \nelse\n \nif\n \nstateChanges\n.\nto\n.\nstatus\n \n==\n \nOSNotificationPermission\n.\ndenied\n \n{\n\n            \nprint\n(\nNotifications not accepted. You can turn them on later under your iOS settings.\n)\n\n         \n}\n\n      \n}\n\n      \n// prints out all properties\n\n      \nprint\n(\nPermissionStateChanges: \n\\n\n\\(\nstateChanges\n)\n)\n\n   \n}\n\n\n   \n// Output:\n\n   \n/*\n\n\n   Thanks for accepting notifications!\n\n\n   PermissionStateChanges:\n\n\n   Optional(\nOSSubscriptionStateChanges:\n\n\n   from: \nOSPermissionState: hasPrompted: 0, status: NotDetermined\n,\n\n\n   to:   \nOSPermissionState: hasPrompted: 1, status: Authorized\n\n\n   \n\n\n   */\n\n\n}\n\n\n\n\n\n\n\n\nObjective-C\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n// AppDelegate.h\n\n\n// Add OSPermissionObserver after UIApplicationDelegate\n\n\n@interface\n \nAppDelegate\n : \nUIResponder\n \nUIApplicationDelegate\n,\n \nOSPermissionObserver\n\n\n@end\n\n\n\n// AppDelegate.m\n\n\n@implementation\n \nAppDelegate\n\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n \n{\n\n  \n// Add your AppDelegate as an obsserver\n\n  \n[\nKontext\n \naddPermissionObserver\n:\nself\n];\n\n\n}\n\n\n\n// Add this new method\n\n\n-\n \n(\nvoid\n)\nonOSPermissionChanged:\n(\nOSPermissionStateChanges\n*\n)\nstateChanges\n \n{\n\n\n    \n// Example of detecting anwsering the permission prompt\n\n    \nif\n \n(\nstateChanges\n.\nfrom\n.\nstatus\n \n==\n \nOSNotificationPermissionNotDetermined\n)\n \n{\n\n      \nif\n \n(\nstateChanges\n.\nto\n.\nstatus\n \n==\n \nOSNotificationPermissionAuthorized\n)\n\n         \nNSLog\n(\n@\nThanks for accepting notifications!\n);\n\n      \nelse\n \nif\n \n(\nstateChanges\n.\nto\n.\nstatus\n \n==\n \nOSNotificationPermissionDenied\n)\n\n         \nNSLog\n(\n@\nNotifications not accepted. You can turn them on later under your iOS settings.\n);\n\n    \n}\n\n\n   \n// prints out all properties \n\n   \nNSLog\n(\n@\nPermissionStateChanges:\n\\n\n%@\n,\n \nstateChanges\n);\n\n\n}\n\n\n\n// Output:\n\n\n/*\n\n\nThanks for accepting notifications!\n\n\nPermissionStateChanges:\n\n\nOSSubscriptionStateChanges:\n\n\nfrom: \nOSPermissionState: hasPrompted: 1, status: NotDetermined\n,\n\n\nto:   \nOSPermissionState: hasPrompted: 1, status: Authorized\n\n\n\n\n*/\n\n\n\n@end\n\n\n\n\n\n\n\n\naddSubscriptionObserver\n\n\nMETHOD\n\n\nThe \nonKontextSubscriptionChanged\n method will be fired on the passed in object when a notification subscription property changes.\n\n\nThis includes the following events:\n\n\n\n\nGetting a push token from Apple\n\n\nGetting a player / user id from Kontext\n\n\nKontext.setSubscription\n is called\n\n\nUser disables or enables notifications\n\n\n\n\nExample\n\n\nExample of setting up with your AppDelegate. Output is showing the capture the device subscribing to Kontext.\n\n\n\n\n\n\nSwift\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n// AppDelegate.swift\n\n\n// Add OSSubscriptionObserver after UIApplicationDelegate\n\n\nclass\n \nAppDelegate\n:\n \nUIResponder\n,\n \nUIApplicationDelegate\n,\n \nOSSubscriptionObserver\n \n{\n\n\n   \nfunc\n \napplication\n(\n_\n \napplication\n:\n \nUIApplication\n,\n \ndidFinishLaunchingWithOptions\n \nlaunchOptions\n:\n \n[\nUIApplicationLaunchOptionsKey\n:\n \nAny\n]?)\n \n-\n \nBool\n \n{\n\n      \n// Add your AppDelegate as an obsserver\n\n      \nKontext\n.\nadd\n(\nself\n \nas\n \nOSSubscriptionObserver\n)\n\n   \n}\n\n\n   \n// Add this new method\n\n   \nfunc\n \nonOSSubscriptionChanged\n(\n_\n \nstateChanges\n:\n \nOSSubscriptionStateChanges\n!)\n \n{\n\n      \nif\n \n!\nstateChanges\n.\nfrom\n.\nsubscribed\n \n \nstateChanges\n.\nto\n.\nsubscribed\n \n{\n\n         \nprint\n(\nSubscribed for Kontext push notifications!\n)\n\n         \n// get player ID\n\n         \nstateChanges\n.\nto\n.\nuserId\n\n      \n}\n\n      \nprint\n(\nSubscriptionStateChange: \n\\n\n\\(\nstateChanges\n)\n)\n\n   \n}\n\n\n   \n// Output:\n\n   \n/*\n\n\n   Subscribed for Kontext push notifications!\n\n\n   PermissionStateChanges:\n\n\n   Optional(\nOSSubscriptionStateChanges:\n\n\n   from: \nOSSubscriptionState: userId: (null), pushToken: 0000000000000000000000000000000000000000000000000000000000000000 userSubscriptionSetting: 1, subscribed: 0\n,\n\n\n   to:   \nOSSubscriptionState: userId: 11111111-222-333-444-555555555555, pushToken: 0000000000000000000000000000000000000000000000000000000000000000, userSubscriptionSetting: 1, subscribed: 1\n\n\n   \n\n\n   */\n\n\n}\n\n\n\n\n\n\n\n\nObjective-C\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n// AppDelegate.h\n\n\n// Add OSSubscriptionObserver after UIApplicationDelegate\n\n\n@interface\n \nAppDelegate\n : \nUIResponder\n \nUIApplicationDelegate\n,\n \nOSSubscriptionObserver\n\n\n@end\n\n\n\n// AppDelegate.m\n\n\n@implementation\n \nAppDelegate\n\n\n\n-\n \n(\nBOOL\n)\napplication:\n(\nUIApplication\n*\n)\napplication\n \ndidFinishLaunchingWithOptions:\n(\nNSDictionary\n \n*\n)\nlaunchOptions\n \n{\n\n  \n// Add your AppDelegate as an obsserver\n\n  \n[\nKontext\n \naddSubscriptionObserver\n:\nself\n];\n\n\n}\n\n\n\n// Add this new method\n\n\n-\n \n(\nvoid\n)\nonOSSubscriptionChanged:\n(\nOSSubscriptionStateChanges\n*\n)\nstateChanges\n \n{\n\n\n    \n// Example of detecting subscribing to Kontext\n\n    \nif\n \n(\n!\nstateChanges\n.\nfrom\n.\nsubscribed\n \n \nstateChanges\n.\nto\n.\nsubscribed\n)\n \n{\n\n      \nNSLog\n(\n@\nSubscribed for Kontext push notifications!\n);\n\n      \n// get player ID\n\n      \nstateChanges\n.\nto\n.\nuserId\n;\n\n    \n}\n\n\n   \n// prints out all properties\n\n   \nNSLog\n(\n@\nSubscriptionStateChanges:\n\\n\n%@\n,\n \nstateChanges\n);\n\n\n}\n\n\n\n// Output:\n\n\n/*\n\n\nSubscribed for Kontext push notifications!\n\n\nPermissionStateChanges:\n\n\nOSSubscriptionStateChanges:\n\n\nfrom: \nOSSubscriptionState: userId: (null), pushToken: 0000000000000000000000000000000000000000000000000000000000000000 userSubscriptionSetting: 1, subscribed: 0\n,\n\n\nto:   \nOSSubscriptionState: userId: 11111111-222-333-444-555555555555, pushToken: 0000000000000000000000000000000000000000000000000000000000000000, userSubscriptionSetting: 1, subscribed: 1\n\n\n\n\n*/\n\n\n\n@end\n\n\n\n\n\n\n\n\nAdvanced Observer Details\n\n\nAny object implementing the \nKontextPermissionObserver\n and/or the \nKontextSubscriptionObserver\n protocols can be added as an observer. You can call \nremovePermissionObserver\n to remove any existing listeners.\nKontext uses a weak reference to the observer to prevent leaks.\n\n\nEvents\n\n\nsendEvent\n\n\nMETHOD\n\n\nTag a user based on an app event of your choosing so later you can create segments on \nKontext platform\n to target these users. Recommend using sendEvents over sendEvent if you need to set more than one tag on a user at a time.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nNSString*\n\n\nKey of your choosing to create or update\n\n\n\n\n\n\nvalue\n\n\nNSString*\n\n\nValue to set on the key.\n\n\n\n\n\n\nonSuccess(Optional)\n\n\nKontextResultSuccessBlock\n\n\nCall if there were no errors sending the tag\n\n\n\n\n\n\nonFailure(Optional)\n\n\nKontextFailureBlock\n\n\nCalled if there was an error\n\n\n\n\n\n\n\n\n\n\n\n\nSwift\n\n\n1\nKontext\n.\nsendEvent\n(\nkey\n,\n \nvalue\n:\n \nvalue\n)\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n[\nKontext\n \nsendEvent\n:\n@\nkey\n \nvalue\n:\n@\nvalue\n];\n\n\n\n\n\n\n\n\nsendEvents\n\n\nMETHOD\n\n\nTag a user based on an app event of your choosing so later you can create segments on \nKontext platform\n to target these users.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkeyValues\n\n\nNSDictionary*\n\n\nKey value pairs of your choosing to create or update.\n\n\n\n\n\n\nonSuccess(Optional)\n\n\nKontextResultSuccessBlock\n\n\nCall if there were no errors sending the tag\n\n\n\n\n\n\nonFailure(Optional)\n\n\nKontextFailureBlock\n\n\nCalled if there was an error\n\n\n\n\n\n\n\n\n\n\n\n\nSwift\n\n\n1\nKontext\n.\nsendEvents\n([\nkey1\n:\n \nvalue1\n,\n \nkey2\n:\n \nvalue2\n])\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n[\nKontext\n \nsendEvents\n:\n@{\n@\nkey1\n \n:\n \n@\nvalue1\n,\n \n@\nkey2\n \n:\n \n@\nvalue2\n}\n];\n\n\n\n\n\n\n\n\nsendScreen\n\n\nMETHOD\n\n\nTag a user based on an app event of your choosing so later you can create segments on \nKontext platform\n to target these users. Recommend using sendEvents over sendEvent if you need to set more than one tag on a user at a time.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nNSString*\n\n\nValue to screen.\n\n\n\n\n\n\nonSuccess(Optional)\n\n\nKontextResultSuccessBlock\n\n\nCall if there were no errors sending the tag\n\n\n\n\n\n\nonFailure(Optional)\n\n\nKontextFailureBlock\n\n\nCalled if there was an error\n\n\n\n\n\n\n\n\n\n\n\n\nSwift\n\n\n1\nKontext\n.\nsendScreen\n(\nScreenName\n)\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n[\nKontext\n \nsendScreen\n:\n@\nScreenName\n];\n\n\n\n\n\n\n\n\nsendUserAttributes\n\n\nMETHOD\n\n\nTag a user based on an app event of your choosing so later you can create segments on \nKontext platform\n to target these users.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkeyValues\n\n\nNSDictionary*\n\n\nKey value pairs of your choosing to create or update.\n\n\n\n\n\n\nonSuccess(Optional)\n\n\nKontextResultSuccessBlock\n\n\nCall if there were no errors sending the tag\n\n\n\n\n\n\nonFailure(Optional)\n\n\nKontextFailureBlock\n\n\nCalled if there was an error\n\n\n\n\n\n\n\n\n\n\n\n\nSwift\n\n\n1\nKontext\n.\nsendEvents\n([\nname\n:\n \nJhon Doe\n,\n \nage\n:\n \n24\n,\n \ngender\n:\n \nM\n,\n \ncity\n:\n \nPune\n])\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n[\nKontext\n \nsendEvents\n:\n@{\n@\nname\n:\n \n@\nJhon Doe\n,\n \n@\nage\n:\n \n@24\n,\n \n@\ngender\n:\n \n@\nM\n,\n \n@\ncity\n:\n \n@\nPune\n}\n];\n\n\n\n\n\n\n\n\nData\n\n\nsetLocationShared\n\n\nMETHOD\n\n\nAllows you to enable or disable Kontext SDK location collection. Due to Apple's \nApp Store Guidelines\n, it is required in iKontext applications to get the user's consent before collecting location. \n\n\npromptLocation\n\n\nMETHOD\n\n\nPrompts the user for location permissions to allow geotagging from the Kontext dashboard. This lets you send notifications based on the device's location.\n\n\nNote: Requires the follow entries in your .plist file.\n\n\n\n\nNSLocationUsageDescription\n (For iKontext 7 and later)\n\n\nNSLocationWhenInUseUsageDescription\n\n  Optional:\n\n\nNSLocationAlwaysAndWhenInUseUsageDescription\n and \nNSLocationAlwaysUsageDescription\n along with \nUIBackgroundModes -\n location\n\n  Example plist image: \nhttps://i.imgur.com/OZDQpyQ.png\n\n\n\n\n\n\n\n\nSwift\n\n\n1\nKontext\n.\npromptLocation\n()\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n[\nKontext\n \npromptLocation\n];\n\n\n\n\n\n\n\n\nSending Notifications\n\n\npostNotification\n\n\nMETHOD\n\n\nAllows you to send notifications from user to user or schedule ones in the future to be delivered to the current device.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nparameters\n\n\nNSDictionary*\n\n\nDictionary of notification options\n\n\n\n\n\n\nonSuccess(Optional)\n\n\nKontextResultSuccessBlock\n\n\nCalled if there were no errors sending the notification\n\n\n\n\n\n\nonFailure(Optional)\n\n\nKontextFailureBlock\n\n\nCalled if there was an error\n\n\n\n\n\n\n\n\n\n\n\n\nSwift\n\n\n1\nKontext\n.\npostNotification\n([\ncontents\n:\n \n[\nen\n:\n \nTest Message\n],\n \ninclude_player_ids\n:\n \n[\n3009e210-3166-11e5-bc1b-db44eb02b120\n]])\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n2\n3\n4\n[\nKontext\n \npostNotification\n:\n@{\n\n   \n@\ncontents\n \n:\n \n@{\n@\nen\n:\n \n@\nTest Message\n}\n,\n\n   \n@\ninclude_player_ids\n:\n \n@[\n@\n3009e210-3166-11e5-bc1b-db44eb02b120\n]\n\n\n}\n];\n\n\n\n\n\n\n\n\nClearKontextNotifications\n\n\nMETHOD\n\n\niOS provides a standard way to clear notifications by clearing badge count, thus there is no specific Kontext API call for clearing notifications.\n\n\nsetSubscription\n\n\nMETHOD\n\n\nYou can call this method with false to opt users out of receiving all notifications through Kontext. You can pass true later to opt users back into notifications.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nenable\n\n\nBOOL\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSwift\n\n\n1\nKontext\n.\nsetSubscription\n(\nfalse\n)\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n[\nKontext\n \nsetSubscription\n:\nfalse\n];\n\n\n\n\n\n\n\n\nEmail\n\n\nsetEmail\n\n\nMETHOD\n\n\nsetEmail\n allows you to set the user's email address with the Kontext SDK. We offer several overloaded versions of this method.\n\n\n\n\n\n\nSwift\n\n\n1\nKontext\n.\nsetEmail\n(\nexample@domain.com\n);\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n[\nKontext\n \nsetEmail\n:\n@\nexample@domain.com\n];\n\n\n\n\n\n\n\n\nlogoutEmail\n\n\nMETHOD\n\n\nIf your app implements logout functionality, you can call \nlogoutEmail\n to dissociate the email from the device:\n\n\n\n\n\n\nSwift\n\n\n1\nKontext\n.\nlogoutEmail\n();\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n[\nKontext\n \nlogoutEmail\n];\n\n\n\n\n\n\n\n\naddEmailSubscriptionObserver\n\n\nMETHOD\n\n\nWe have also added a new email subscription observer to track changes to email subscriptions (ie. the user sets their email or logs out). In order to subscribe to email subscription changes you can implement the following:\n\n\n\n\n\n\nSwift\n\n\n1\nKontext\n.\nadd\n(\nself\n \nas\n \nOSEmailSubscriptionObserver\n)\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n[\nKontext\n \naddEmailSubscriptionObserver\n:\nself\n];\n\n\n\n\n\n\n\n\nNow, whenever the email subscription changes, this method will be called:\n\n\n\n\n\n\nSwift\n\n\n1\n2\n3\nfunc\n \nonOSEmailSubscriptionChanged\n(\n_\n \nstateChanges\n:\n \nOSEmailSubscriptionStateChanges\n!)\n \n{\n \n\n\n}\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n2\n3\n-(\nvoid\n)\nonOSEmailSubscriptionChanged:\n(\nOSEmailSubscriptionStateChanges\n \n*\n)\nstateChanges\n \n{\n\n\n\n}\n\n\n\n\n\n\n\n\nNotifications Events\n\n\nKontextHandleNotificationReceivedBlock\n\n\nCALLBACK\n\n\nCalled when the app receives a notification while in focus only.\n\n\n\n\nNote+\n\n\nIf you need this to be called when your app is in the background, set content_available to true when you create your notification. The \"force-quit\" state (i.e app was swiped away) is not currently supported.\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnotification\n\n\nKontextNotification\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSwift\n\n\n1\n2\n3\n{\n \nnotification\n \nin\n\n    \nprint\n(\nReceived Notification - \n\\(\nnotification\n.\npayload\n.\nnotificationID\n)\n - \n\\(\nnotification\n.\npayload\n.\ntitle\n)\n)\n\n\n}\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n2\n3\n^\n(\nOSNotification\n \n*\nnotification\n)\n \n{\n\n    \nNSLog\n(\n@\nReceived Notification - %@ - %@\n,\n \nnotification\n.\npayload\n.\nnotificationID\n,\n \nnotification\n.\npayload\n.\ntitle\n);\n\n\n}\n\n\n\n\n\n\n\n\nKontextHandleNotificationActionBlock\n\n\nCALLBACK\n\n\nCalled when the user opens or taps an action on a notification.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nresult\n\n\nKontextNotificationOpenedResult\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSwift\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n{\n \nresult\n \nin\n\n\n    \n// This block gets called when the user reacts to a notification received\n\n    \nlet\n \npayload\n:\n \nOSNotificationPayload\n \n=\n \nresult\n!.\nnotification\n.\npayload\n\n    \nvar\n \nfullMessage\n \n=\n \npayload\n.\nbody\n\n\n    \n//Try to fetch the action selected\n\n    \nif\n \nlet\n \nadditionalData\n \n=\n \npayload\n.\nadditionalData\n,\n \nactionSelected\n \n=\n \nadditionalData\n[\nactionSelected\n]\n \nas\n?\n \nString\n \n{\n\n        \nfullMessage\n \n=\n  \nfullMessage\n \n+\n \n\\n\nPressed ButtonId:\n\\(\nactionSelected\n)\n\n    \n}\n\n    \nprint\n(\nfullMessage = \n\\(\nfullMessage\n)\n)\n\n\n}\n\n\n\n\n\n\n\n\nObjective-C\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n^\n(\nKontextNotificationOpenedResult\n \n*\nresult\n)\n \n{\n\n\n   \n// This block gets called when the user opens or taps an action on a notification\n\n   \nKontextNotificationPayload\n*\n \npayload\n \n=\n \nresult\n.\nnotification\n.\npayload\n;\n\n\n   \nNSString\n*\n \nmessageTitle\n \n=\n \n@\nKontext Example\n;\n\n   \nNSString\n*\n \nfullMessage\n \n=\n \n[\npayload\n.\nbody\n \ncopy\n];\n\n\n   \nif\n \n(\npayload\n.\nadditionalData\n)\n \n{\n\n      \nif\n \n(\npayload\n.\ntitle\n)\n\n         \nmessageTitle\n \n=\n \npayload\n.\ntitle\n;\n\n\n      \nNSDictionary\n*\n \nadditionalData\n \n=\n \npayload\n.\nadditionalData\n;\n\n\n      \nif\n \n(\nadditionalData\n[\n@\nactionSelected\n])\n\n         \nfullMessage\n \n=\n \n[\nfullMessage\n \nstringByAppendingString\n:[\nNSString\n \nstringWithFormat\n:\n@\n\\n\nPressed ButtonId:%@\n,\n \nadditionalData\n[\n@\nactionSelected\n]]];\n\n   \n}\n\n\n   \nUIAlertView\n*\n \nalertView\n \n=\n \n[[\nUIAlertView\n \nalloc\n]\n\n                               \ninitWithTitle\n:\nmessageTitle\n\n                                     \nmessage\n:\nfullMessage\n\n                                    \ndelegate\n:\nself\n\n                           \ncancelButtonTitle\n:\n@\nClose\n\n                          \notherButtonTitles\n:\nnil\n,\n \nnil\n];\n\n   \n[\nalertView\n \nshow\n];\n\n\n}\n\n\n\n\n\n\n\n\nKontextNotificationOpenedResult\n\n\nINTERFACE ELEMENT\n\n\nThe information returned from a notification the user received. Resulting class passed to \nKontextHandleNotificationActionBlock\n.\n\n\n\n\n\n\n\n\nClass Properties\n\n\n\n\n\n\n\n\n\n\n\n\nnotification\n(\nKontextNotification\n);\n\n\n\n\n\n\n\n\naction\n(\nKontextNotificationAction\n);|\n\n\n\n\n\n\n\n\n\n\nKontextNotification\n\n\nINTERFACE ELEMENT\n\n\nThe notification the user received.\n\n\n\n\n\n\n\n\nClass Properties\n\n\n\n\n\n\n\n\n\n\n\n\npayload\n(\nKontextNotificationPayload\n);\n\n\n\n\n\n\n\n\ndisplayType\n(\nKontextNotificationDisplayType\n);\n\n\n\n\n\n\n\n\nshown\n(\nBOOL\n);\n\n\nTrue when the user was able to see the notification. False when app is in focus and in-app alerts are disabled, or the remote notification is silent.\n\n\n\n\n\n\nsilentNotification\n(\nBOOL\n);\n\n\nTrue when the received notification is silent. Silent means there is no alert, sound, or badge payload in the APS dictionary. Requires remote-notification within UIBackgroundModes array of the Info.plist\n\n\n\n\n\n\n\n\nKontextNotificationAction\n\n\nINTERFACE ELEMENT\n\n\nThe action the user took on the notification.\n\n\n\n\n\n\n\n\nClass Properties\n\n\n\n\n\n\n\n\n\n\n\n\nactionID\n(\nNSString\n);\n\n\nThe ID associated with the button tapped. NULL when the actionType is NotificationTapped or InAppAlertClosed.\n\n\n\n\n\n\ntype\n(\nKontextNotificationActionType\n);\n\n\nThe type of the notification action.\n\n\n\n\n\n\n\n\nKontextNotificationActionType\n\n\nINTERFACE ELEMENT\n\n\nThe action type (\nNSUInteger Enum\n) associated to an KontextNotificationAction object.\n\n\n\n\n\n\n\n\nNSUInteger Enum Properties\n\n\n\n\n\n\n\n\n\n\n\n\nopened\n\n\n\n\n\n\n\n\nActionTaken\n\n\n\n\n\n\n\n\n\n\nKontextNotificationDisplayType\n\n\nINTERFACE ELEMENT\n\n\nThe way in which a notification was displayed to the user (\nNSUInteger Enum\n).\n\n\n\n\n\n\n\n\nNSUInteger Enum Properties\n\n\nRaw Value\n\n\n\n\n\n\n\n\n\n\n\n\nNotification\n\n\n2\n\n\niOS native notification display.\n\n\n\n\n\n\nInAppAlert\n\n\n1\n\n\nDefault UIAlertView display.\n\n\n\n\n\n\nNone\n\n\n0\n\n\nNotification is silent, or app is in focus but InAppAlertNotifications are disabled.\n\n\n\n\n\n\n\n\nKontextNotificationPayload\n\n\nINTERFACE ELEMENT\n\n\nContents and settings of the notification the user received.\n\n\n\n\n\n\n\n\nClass Properties\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnotificationID\n\n\nNSString\n\n\nKontext notification UUID\n\n\n\n\n\n\ncontentAvailable\n\n\nBOOL\n\n\nProvide this key with a value of 1 to indicate that new content is available. Including this key and value means that when your app is launched in the background or resumed\u00a0\napplication\n:\ndidReceiveRemoteNotification\n:\nfetchCompletionHandler\n:\n\u00a0is called.\n\n\n\n\n\n\nbadge\n\n\nNSInteger\n\n\nThe badge number assigned to the application icon\n\n\n\n\n\n\nsound\n\n\nNSString\n\n\nThe sound parameter passed to the notification. By default set to\u00a0\nUILocalNotificationDefaultSoundName\n.\u00a0\nRead more about custom sounds\n\n\n\n\n\n\ntitle\n\n\nNSString\n\n\nTitle text of the notification\n\n\n\n\n\n\nbody\n\n\nNSString\n\n\nBody text of the notification\n\n\n\n\n\n\nsubtitle\n\n\nNSString\n\n\niOS 10+\u00a0- subtitle text of the notification\n\n\n\n\n\n\nlaunchUrl\n\n\nNSString\n\n\nWeb address to launch within the app via a\u00a0\nUIWebView\n\n\n\n\n\n\nadditionalData\n\n\nNSDictonary\n\n\nAdditional Data add to the notification by you\n\n\n\n\n\n\nattachments\n\n\nNSDictonary\n\n\niOS 10+\u00a0- Attachments sent as part of the rich notification\n\n\n\n\n\n\nactionButtons\n\n\nNSArray\n\n\nAction buttons set on the notification\n\n\n\n\n\n\nrawPayload\n\n\nNSDictonary\n\n\nHolds the raw APS payload received\n\n\n\n\n\n\n\n\nDebug\n\n\nsetLogLevel\n\n\nMETHOD\n\n\nEnable logging to help debug if you run into an issue setting up Kontext. This selector is static so you can call it before Kontext init. The following options are available with increasingly more information; \nONE_S_LL_NONE\n, \nONE_S_LL_FATAL\n, \nONE_S_LL_ERROR\n, \nONE_S_LL_WARN\n, \nONE_S_LL_INFO\n, \nONE_S_LL_DEBUG\n, \nONE_S_LL_VERBOSE\n.\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlogLevel\n\n\nLOG_LEVEL\n\n\nSets the logging level to print to the Xcode log\n\n\n\n\n\n\nvisualLevel\n\n\nLOG_LEVEL\n\n\nSets the logging level to show as alert dialogs.\n\n\n\n\n\n\n\n\n\n\n\n\nSwift\n\n\n1\nKontext\n.\nsetLogLevel\n(.\nLL_DEBUG\n,\n \nvisualLevel\n:\n \n.\nLL_DEBUG\n)\n\n\n\n\n\n\n\n\nObjective-C\n\n\n1\n[\nKontext\n \nsetLogLevel\n:\nONE_S_LL_DEBUG\n \nvisualLevel\n:\nONE_S_LL_DEBUG\n];", 
            "title": "SDK Reference"
        }, 
        {
            "location": "/iOS/reference/#ios-native-sdk", 
            "text": "Kontext iOS Native SDK Reference   Just starting with iOS?  Check out our\u00a0 iOS SDK Setup  guide.    Upgrade to 2.5.1+  A number the methods and classes below were recently added in our 3.5.1 SDK. Make sure you have updated to this version.   For Developers     Calls  Type  Description      Initialization      initWithLaunchOptions  Method  Initialize Kontext         Privacy      setRequiresUserPrivacyConsent  Mothod     consentGranted  Mothod     requiresUserPrivacyConsent  boolean          Settings      KontextSettingsKeyAutoPrompt  key     KontextSettingsKeyInAppLaunchURL  key     inFocusDisplayType  Property          Prompting      promptForPushNotificationsWithUserResponse  Method          Status      getPermissionSubscriptionState  Method     addPermissionObserver  Method     addSubscriptionObserver  Method          Events      sendEvent  Method     sendEvents  Method     sendScreen  Method     sendUserAttributes  Method          Data      setLocationShared  Method     promptLocation  Method          Sending Notifications      postNotification  Method     clearKontextNotifications  Method     setSubscription  Method          Email      setEmail  Method     logoutEmail  Method     addEmailSubscriptionObserver  Method          Notification Events      handleNotificationReceived  Method     handleNotificationAction  Method          Objects      KontextNotificationOpenedResult  Object     KontextNotification  Object     KontextNotificationAction  Object     KontextNotificationActionType  Object     KontextNotificationDisplayType  Object     KontextNotificationPayload  Object          Debug      setLogLevel  Mothod", 
            "title": "iOS Native SDK"
        }, 
        {
            "location": "/iOS/reference/#initialization", 
            "text": "", 
            "title": "Initialization"
        }, 
        {
            "location": "/iOS/reference/#initwithlaunchoptions", 
            "text": "METHOD  Must be called from  didFinishLaunchingWithOptions  in  AppDelegate.m .     Parameter  Type  Description      launchOptions  NSDictionary*  REQUIRED\u00a0launchOptions that you received from\u00a0 didFinishLaunchingWithOptions    appId  NSString*  REQUIRED\u00a0Your Kontext app id, available in\u00a0 Keys   IDs    callback  KontextHandleNotificationReceivedBlock  Function to be called when a notification is received    callback  KontextHandleNotificationActionBlock  Function to be called when a user reacts to a notification received    settings  NSDictionary*  Customization settings to change Kontext's default behavior      iOS 8+ Notes    application : didRegisterForRemoteNotificationsWithDeviceToken :  will still fire even if KontextSettingsKeyAutoPrompt is set to false.    Replace any of your  isRegisteredForRemoteNotifications  calls with  currentUserNotificationSettings  or getPermissionSubscriptionState.     iOS 8+ Notes   application : didRegisterForRemoteNotificationsWithDeviceToken :  will still fire even if  KontextSettingsKeyAutoPrompt  is set to  false .  Replace any of your  isRegisteredForRemoteNotifications  calls with  currentUserNotificationSettings  or  getPermissionSubscriptionState .     Swift   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40 func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ]?)   -   Bool   { \n\n    let   notificationReceivedBlock :   OSHandleNotificationReceivedBlock   =   {   notification   in \n\n       print ( Received Notification:  \\( notification !. payload . notificationID ) ) \n    } \n\n    let   notificationOpenedBlock :   OSHandleNotificationActionBlock   =   {   result   in \n       // This block gets called when the user reacts to a notification received \n       let   payload :   OSNotificationPayload   =   result !. notification . payload \n\n       var   fullMessage   =   payload . body \n       print ( Message =  \\( fullMessage ) ) \n\n       if   payload . additionalData   !=   nil   { \n          if   payload . title   !=   nil   { \n             let   messageTitle   =   payload . title \n                print ( Message Title =  \\( messageTitle ! ) ) \n          } \n\n          let   additionalData   =   payload . additionalData \n          if   additionalData ?[ actionSelected ]   !=   nil   { \n             fullMessage   =   fullMessage !   +   \\n Pressed ButtonID:  \\( additionalData ![ actionSelected ] ) \n          } \n       } \n    } \n\n    let   onesignalInitSettings   =   [ kOSSettingsKeyAutoPrompt :   false , \n       kOSSettingsKeyInAppLaunchURL :   true ] \n\n    Kontext . initWithLaunchOptions ( launchOptions ,  \n       appId :   YOUR_KONTEXT_APP_ID ,  \n       handleNotificationReceived :   notificationReceivedBlock ,  \n       handleNotificationAction :   notificationOpenedBlock ,  \n       settings :   onesignalInitSettings ) \n\n    Kontext . inFocusDisplayType   =   OSNotificationDisplayType . notification \n\n    return   true  }     Objective-C   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42 -   ( BOOL ) application: ( UIApplication * ) application   didFinishLaunchingWithOptions: ( NSDictionary * ) launchOptions   { \n\n   id   notificationReceiverBlock   =   ^ ( OSNotification   * notification )   { \n     NSLog ( @ Received Notification - %@ ,   notification . payload . notificationID ); \n   }; \n\n   id   notificationOpenedBlock   =   ^ ( OSNotificationOpenedResult   * result )   { \n         // This block gets called when the user reacts to a notification received \n         OSNotificationPayload *   payload   =   result . notification . payload ; \n\n         NSString *   messageTitle   =   @ Kontext Example ; \n         NSString *   fullMessage   =   [ payload . body   copy ]; \n\n         if   ( payload . additionalData )   { \n\n             if ( payload . title ) \n                 messageTitle   =   payload . title ; \n\n             NSDictionary *   additionalData   =   payload . additionalData ; \n\n             if   ( additionalData [ @ actionSelected ]) \n                 fullMessage   =   [ fullMessage   stringByAppendingString :[ NSString   stringWithFormat : @ \\n Pressed ButtonId:%@ ,   additionalData [ @ actionSelected ]]]; \n         } \n\n         UIAlertView *   alertView   =   [[ UIAlertView   alloc ]   initWithTitle : messageTitle \n                                                             message : fullMessage \n                                                            delegate : self \n                                                   cancelButtonTitle : @ Close \n                                                   otherButtonTitles : nil ,   nil ]; \n         [ alertView   show ]; \n\n    }; \n\n    id   onesignalInitSettings   =   @{ kOSSettingsKeyAutoPrompt   :   @YES } ; \n\n    [ Kontext   initWithLaunchOptions : launchOptions \n                               appId : @ YOUR_KONTEXT_APP_ID \n          handleNotificationReceived : notificationReceiverBlock \n            handleNotificationAction : notificationOpenedBlock \n                            settings : onesignalInitSettings ];  }", 
            "title": "initWithLaunchOptions"
        }, 
        {
            "location": "/iOS/reference/#privacy", 
            "text": "", 
            "title": "Privacy"
        }, 
        {
            "location": "/iOS/reference/#setrequiresuserprivacyconsent", 
            "text": "METHOD  For GDPR users, your application should call this method  before  initialization of the SDK. If you pass in  true , your application will need to call  provideConsent(true)  before the Kontext SDK gets fully initialized. Until this happens, you can continue to call methods (such as  sendEvents() ), but nothing will happen.    Swift  1\n2\n3\n4 //to require the user s consent before the SDK initializes  Kontext . setRequiresUserPrivacyConsent ( true );  Kontext . initWithLaunchOptions ( launchOptions ,   appId :   YOUR_KONTEXT_APP_ID );     Objective-C  1\n2\n3\n4 //to require the user s consent before the SDK initializes  [ Kontext   setRequiresUserPrivacyConsent : true ];  [ Kontext   initWithLaunchOptions : launchOptions   appId : @ YOUR_KONTEXT_APP_ID ];", 
            "title": "setRequiresUserPrivacyConsent"
        }, 
        {
            "location": "/iOS/reference/#consentgranted", 
            "text": "METHOD  If you set the SDK to require the user's privacy consent, your application can use this method once the user does or doesn't provide privacy consent to use the Kontext SDK.    Swift  1\n2\n3\n4 @IBAction   func   userTappedProvideConsentButton ( _   sender   :   UIButton )   { \n   //this will complete the initialization of the SDK \n     Kontext . provideConsent ( true );   }     Objective-C  1\n2\n3\n4 -   ( IBAction ) setEmailButtonPressed: ( UIButton   * ) sender   { \n   //this will complete the initialization of the SDK \n   [ Kontext   provideConsent : true ];  }", 
            "title": "consentGranted"
        }, 
        {
            "location": "/iOS/reference/#requiresuserprivacyconsent", 
            "text": "BOOLEAN  You can use this property to check if the Kontext SDK is waiting for the user to provide privacy consent.  true  - Indicates that the Kontext SDK hasn't received the user's privacy consent yet false  - Either the user has already provided consent, or your app isn't set to require consent.", 
            "title": "requiresUserPrivacyConsent"
        }, 
        {
            "location": "/iOS/reference/#settings", 
            "text": "", 
            "title": "Settings"
        }, 
        {
            "location": "/iOS/reference/#kontextsettingskeyautoprompt", 
            "text": "KEY  true  (DEFAULT) - automatically prompts for notifications permissions. false  - disables auto prompt.", 
            "title": "kontextSettingsKeyAutoPrompt"
        }, 
        {
            "location": "/iOS/reference/#kontextsettingskeyinapplaunchurl", 
            "text": "KEY  true  (DEFAULT) - Open all URLs with a in-app WebView window. false  - Launches Safari with the URL OR other app (if deep linked or custom URL scheme passed).", 
            "title": "kontextSettingsKeyInAppLaunchURL"
        }, 
        {
            "location": "/iOS/reference/#infocusdisplaytype", 
            "text": "PROPERTY  Setting to control how Kontext notifications will be shown when one is received while your app is in focus, for apps targeting.  KontextNotificationDisplayTypeNotification  - Native notification display KontextNotificationDisplayTypeInAppAlert  (DEFAULT) - Alert dialog display. KontextNotificationDisplayTypeNone  - Notification is silent and not shown  Swift format:  KontextNotificationDisplayType.notification  KontextNotificationDisplayType.inAppAlert  KontextNotificationDisplayType.none    Swift  1 Kontext . inFocusDisplayType   =   OSNotificationDisplayType . notification     Objective-C  1 Kontext . inFocusDisplayType   =   OSNotificationDisplayTypeNotification ;      iOS 9 and below  The Notification setting will fall back to InAppAlert .", 
            "title": "inFocusDisplayType"
        }, 
        {
            "location": "/iOS/reference/#registering-push", 
            "text": "", 
            "title": "Registering Push"
        }, 
        {
            "location": "/iOS/reference/#promptforpushnotificationswithuserresponse", 
            "text": "METHOD  Prompt the user for notification permissions. Callback fires as soon as the user accepts or declines notifications.", 
            "title": "promptForPushNotificationsWithUserResponse"
        }, 
        {
            "location": "/iOS/reference/#requirements", 
            "text": "Must set  kontextSettingsKeyAutoPrompt  to  false  when calling  initWithLaunchOptions .", 
            "title": "Requirements"
        }, 
        {
            "location": "/iOS/reference/#recommendations", 
            "text": "You can only prompt once so it is recommend to explain what benefits notifications will give the user.", 
            "title": "Recommendations"
        }, 
        {
            "location": "/iOS/reference/#example", 
            "text": "Swift  1\n2\n3\n4\n5 // Call when you want to prompt the user to accept push notifications.   // Only call once and only if you set kOSSettingsKeyAutoPrompt in AppDelegate to false.  Kontext . promptForPushNotifications ( userResponse :   {   accepted   in \n    print ( User accepted notifications:  \\( accepted ) )  })     Objective-C  1\n2\n3 [ Kontext   promptForPushNotificationsWithUserResponse : ^ ( BOOL   accepted )   { \n   NSLog ( @ Accepted Notifications?: %d ,   accepted );  }];", 
            "title": "Example"
        }, 
        {
            "location": "/iOS/reference/#status", 
            "text": "", 
            "title": "Status"
        }, 
        {
            "location": "/iOS/reference/#getpermissionsubscriptionstate", 
            "text": "METHOD  Get the current notification and permission state. Returns a  KontextPermissionSubscriptionState  type described below.", 
            "title": "getPermissionSubscriptionState"
        }, 
        {
            "location": "/iOS/reference/#kontextpermissionsubscriptionstate", 
            "text": "Parameter  Type  Description      permissionStatus  KontextPermissionState*  iKontext Notification Permissions state    subscriptionStatus  KontextSubscriptionState*  Apple and Kontext subscription state       Swift   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 let   status :   OSPermissionSubscriptionState   =   Kontext . getPermissionSubscriptionState ()  let   hasPrompted   =   status . permissionStatus . hasPrompted  print ( hasPrompted =  \\( hasPrompted ) )  let   userStatus   =   status . permissionStatus . status  print ( userStatus =  \\( userStatus ) )  let   isSubscribed   =   status . subscriptionStatus . subscribed  print ( isSubscribed =  \\( isSubscribed ) )  let   userSubscriptionSetting   =   status . subscriptionStatus . userSubscriptionSetting  print ( userSubscriptionSetting =  \\( userSubscriptionSetting ) )  let   userID   =   status . subscriptionStatus . userId  print ( userID =  \\( userID ) )  let   pushToken   =   status . subscriptionStatus . pushToken  print ( pushToken =  \\( pushToken ) )     Objective-C  1\n2\n3\n4\n5\n6\n7\n8 OSPermissionSubscriptionState *   status   =   [ Kontext   getPermissionSubscriptionState ];  status . permissionStatus . hasPrompted ;  status . permissionStatus . status ;  status . subscriptionStatus . subscribed ;  status . subscriptionStatus . userSubscriptionSetting ;  status . subscriptionStatus . userId ;  status . subscriptionStatus . pushToken ;", 
            "title": "KontextPermissionSubscriptionState"
        }, 
        {
            "location": "/iOS/reference/#addpermissionobserver", 
            "text": "METHOD  The  onKontextPermissionChanged  method will be fired on the passed in object when a notification permission setting changes.\nThis includes the following events:    Notification permission prompt shown  The user accepting or declining the permission prompt  Enabling/disabling notifications for your app in the iKontext Settings after returning to your app.", 
            "title": "addPermissionObserver"
        }, 
        {
            "location": "/iOS/reference/#example_1", 
            "text": "Example of setting up with your AppDelegate.\nOutput is showings the user accepting the notification permission prompt.    Swift   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33 // AppDelegate.swift  // Add OSPermissionObserver after UIApplicationDelegate  class   AppDelegate :   UIResponder ,   UIApplicationDelegate ,   OSPermissionObserver   { \n\n    func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ]?)   -   Bool   { \n       // Add your AppDelegate as an obsserver \n       Kontext . add ( self   as   OSPermissionObserver ) \n    } \n\n    // Add this new method \n    func   onOSPermissionChanged ( _   stateChanges :   OSPermissionStateChanges !)   { \n       // Example of detecting answering the permission prompt \n       if   stateChanges . from . status   ==   OSNotificationPermission . notDetermined   { \n          if   stateChanges . to . status   ==   OSNotificationPermission . authorized   { \n             print ( Thanks for accepting notifications! ) \n          }   else   if   stateChanges . to . status   ==   OSNotificationPermission . denied   { \n             print ( Notifications not accepted. You can turn them on later under your iOS settings. ) \n          } \n       } \n       // prints out all properties \n       print ( PermissionStateChanges:  \\n \\( stateChanges ) ) \n    } \n\n    // Output: \n    /*     Thanks for accepting notifications!     PermissionStateChanges:     Optional( OSSubscriptionStateChanges:     from:  OSPermissionState: hasPrompted: 0, status: NotDetermined ,     to:    OSPermissionState: hasPrompted: 1, status: Authorized          */  }     Objective-C   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39 // AppDelegate.h  // Add OSPermissionObserver after UIApplicationDelegate  @interface   AppDelegate  :  UIResponder   UIApplicationDelegate ,   OSPermissionObserver  @end  // AppDelegate.m  @implementation   AppDelegate  -   ( BOOL ) application: ( UIApplication * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions   { \n   // Add your AppDelegate as an obsserver \n   [ Kontext   addPermissionObserver : self ];  }  // Add this new method  -   ( void ) onOSPermissionChanged: ( OSPermissionStateChanges * ) stateChanges   { \n\n     // Example of detecting anwsering the permission prompt \n     if   ( stateChanges . from . status   ==   OSNotificationPermissionNotDetermined )   { \n       if   ( stateChanges . to . status   ==   OSNotificationPermissionAuthorized ) \n          NSLog ( @ Thanks for accepting notifications! ); \n       else   if   ( stateChanges . to . status   ==   OSNotificationPermissionDenied ) \n          NSLog ( @ Notifications not accepted. You can turn them on later under your iOS settings. ); \n     } \n\n    // prints out all properties  \n    NSLog ( @ PermissionStateChanges: \\n %@ ,   stateChanges );  }  // Output:  /*  Thanks for accepting notifications!  PermissionStateChanges:  OSSubscriptionStateChanges:  from:  OSPermissionState: hasPrompted: 1, status: NotDetermined ,  to:    OSPermissionState: hasPrompted: 1, status: Authorized   */  @end", 
            "title": "Example"
        }, 
        {
            "location": "/iOS/reference/#addsubscriptionobserver", 
            "text": "METHOD  The  onKontextSubscriptionChanged  method will be fired on the passed in object when a notification subscription property changes.  This includes the following events:   Getting a push token from Apple  Getting a player / user id from Kontext  Kontext.setSubscription  is called  User disables or enables notifications", 
            "title": "addSubscriptionObserver"
        }, 
        {
            "location": "/iOS/reference/#example_2", 
            "text": "Example of setting up with your AppDelegate. Output is showing the capture the device subscribing to Kontext.    Swift   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29 // AppDelegate.swift  // Add OSSubscriptionObserver after UIApplicationDelegate  class   AppDelegate :   UIResponder ,   UIApplicationDelegate ,   OSSubscriptionObserver   { \n\n    func   application ( _   application :   UIApplication ,   didFinishLaunchingWithOptions   launchOptions :   [ UIApplicationLaunchOptionsKey :   Any ]?)   -   Bool   { \n       // Add your AppDelegate as an obsserver \n       Kontext . add ( self   as   OSSubscriptionObserver ) \n    } \n\n    // Add this new method \n    func   onOSSubscriptionChanged ( _   stateChanges :   OSSubscriptionStateChanges !)   { \n       if   ! stateChanges . from . subscribed     stateChanges . to . subscribed   { \n          print ( Subscribed for Kontext push notifications! ) \n          // get player ID \n          stateChanges . to . userId \n       } \n       print ( SubscriptionStateChange:  \\n \\( stateChanges ) ) \n    } \n\n    // Output: \n    /*     Subscribed for Kontext push notifications!     PermissionStateChanges:     Optional( OSSubscriptionStateChanges:     from:  OSSubscriptionState: userId: (null), pushToken: 0000000000000000000000000000000000000000000000000000000000000000 userSubscriptionSetting: 1, subscribed: 0 ,     to:    OSSubscriptionState: userId: 11111111-222-333-444-555555555555, pushToken: 0000000000000000000000000000000000000000000000000000000000000000, userSubscriptionSetting: 1, subscribed: 1          */  }     Objective-C   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38 // AppDelegate.h  // Add OSSubscriptionObserver after UIApplicationDelegate  @interface   AppDelegate  :  UIResponder   UIApplicationDelegate ,   OSSubscriptionObserver  @end  // AppDelegate.m  @implementation   AppDelegate  -   ( BOOL ) application: ( UIApplication * ) application   didFinishLaunchingWithOptions: ( NSDictionary   * ) launchOptions   { \n   // Add your AppDelegate as an obsserver \n   [ Kontext   addSubscriptionObserver : self ];  }  // Add this new method  -   ( void ) onOSSubscriptionChanged: ( OSSubscriptionStateChanges * ) stateChanges   { \n\n     // Example of detecting subscribing to Kontext \n     if   ( ! stateChanges . from . subscribed     stateChanges . to . subscribed )   { \n       NSLog ( @ Subscribed for Kontext push notifications! ); \n       // get player ID \n       stateChanges . to . userId ; \n     } \n\n    // prints out all properties \n    NSLog ( @ SubscriptionStateChanges: \\n %@ ,   stateChanges );  }  // Output:  /*  Subscribed for Kontext push notifications!  PermissionStateChanges:  OSSubscriptionStateChanges:  from:  OSSubscriptionState: userId: (null), pushToken: 0000000000000000000000000000000000000000000000000000000000000000 userSubscriptionSetting: 1, subscribed: 0 ,  to:    OSSubscriptionState: userId: 11111111-222-333-444-555555555555, pushToken: 0000000000000000000000000000000000000000000000000000000000000000, userSubscriptionSetting: 1, subscribed: 1   */  @end", 
            "title": "Example"
        }, 
        {
            "location": "/iOS/reference/#advanced-observer-details", 
            "text": "Any object implementing the  KontextPermissionObserver  and/or the  KontextSubscriptionObserver  protocols can be added as an observer. You can call  removePermissionObserver  to remove any existing listeners.\nKontext uses a weak reference to the observer to prevent leaks.", 
            "title": "Advanced Observer Details"
        }, 
        {
            "location": "/iOS/reference/#events", 
            "text": "", 
            "title": "Events"
        }, 
        {
            "location": "/iOS/reference/#sendevent", 
            "text": "METHOD  Tag a user based on an app event of your choosing so later you can create segments on  Kontext platform  to target these users. Recommend using sendEvents over sendEvent if you need to set more than one tag on a user at a time.     Parameter  Type  Description      key  NSString*  Key of your choosing to create or update    value  NSString*  Value to set on the key.    onSuccess(Optional)  KontextResultSuccessBlock  Call if there were no errors sending the tag    onFailure(Optional)  KontextFailureBlock  Called if there was an error       Swift  1 Kontext . sendEvent ( key ,   value :   value )     Objective-C  1 [ Kontext   sendEvent : @ key   value : @ value ];", 
            "title": "sendEvent"
        }, 
        {
            "location": "/iOS/reference/#sendevents", 
            "text": "METHOD  Tag a user based on an app event of your choosing so later you can create segments on  Kontext platform  to target these users.     Parameter  Type  Description      keyValues  NSDictionary*  Key value pairs of your choosing to create or update.    onSuccess(Optional)  KontextResultSuccessBlock  Call if there were no errors sending the tag    onFailure(Optional)  KontextFailureBlock  Called if there was an error       Swift  1 Kontext . sendEvents ([ key1 :   value1 ,   key2 :   value2 ])     Objective-C  1 [ Kontext   sendEvents : @{ @ key1   :   @ value1 ,   @ key2   :   @ value2 } ];", 
            "title": "sendEvents"
        }, 
        {
            "location": "/iOS/reference/#sendscreen", 
            "text": "METHOD  Tag a user based on an app event of your choosing so later you can create segments on  Kontext platform  to target these users. Recommend using sendEvents over sendEvent if you need to set more than one tag on a user at a time.     Parameter  Type  Description      value  NSString*  Value to screen.    onSuccess(Optional)  KontextResultSuccessBlock  Call if there were no errors sending the tag    onFailure(Optional)  KontextFailureBlock  Called if there was an error       Swift  1 Kontext . sendScreen ( ScreenName )     Objective-C  1 [ Kontext   sendScreen : @ ScreenName ];", 
            "title": "sendScreen"
        }, 
        {
            "location": "/iOS/reference/#senduserattributes", 
            "text": "METHOD  Tag a user based on an app event of your choosing so later you can create segments on  Kontext platform  to target these users.     Parameter  Type  Description      keyValues  NSDictionary*  Key value pairs of your choosing to create or update.    onSuccess(Optional)  KontextResultSuccessBlock  Call if there were no errors sending the tag    onFailure(Optional)  KontextFailureBlock  Called if there was an error       Swift  1 Kontext . sendEvents ([ name :   Jhon Doe ,   age :   24 ,   gender :   M ,   city :   Pune ])     Objective-C  1 [ Kontext   sendEvents : @{ @ name :   @ Jhon Doe ,   @ age :   @24 ,   @ gender :   @ M ,   @ city :   @ Pune } ];", 
            "title": "sendUserAttributes"
        }, 
        {
            "location": "/iOS/reference/#data", 
            "text": "", 
            "title": "Data"
        }, 
        {
            "location": "/iOS/reference/#setlocationshared", 
            "text": "METHOD  Allows you to enable or disable Kontext SDK location collection. Due to Apple's  App Store Guidelines , it is required in iKontext applications to get the user's consent before collecting location.", 
            "title": "setLocationShared"
        }, 
        {
            "location": "/iOS/reference/#promptlocation", 
            "text": "METHOD  Prompts the user for location permissions to allow geotagging from the Kontext dashboard. This lets you send notifications based on the device's location.  Note: Requires the follow entries in your .plist file.   NSLocationUsageDescription  (For iKontext 7 and later)  NSLocationWhenInUseUsageDescription \n  Optional:  NSLocationAlwaysAndWhenInUseUsageDescription  and  NSLocationAlwaysUsageDescription  along with  UIBackgroundModes -  location \n  Example plist image:  https://i.imgur.com/OZDQpyQ.png     Swift  1 Kontext . promptLocation ()     Objective-C  1 [ Kontext   promptLocation ];", 
            "title": "promptLocation"
        }, 
        {
            "location": "/iOS/reference/#sending-notifications", 
            "text": "", 
            "title": "Sending Notifications"
        }, 
        {
            "location": "/iOS/reference/#postnotification", 
            "text": "METHOD  Allows you to send notifications from user to user or schedule ones in the future to be delivered to the current device.     Parameter  Type  Description      parameters  NSDictionary*  Dictionary of notification options    onSuccess(Optional)  KontextResultSuccessBlock  Called if there were no errors sending the notification    onFailure(Optional)  KontextFailureBlock  Called if there was an error       Swift  1 Kontext . postNotification ([ contents :   [ en :   Test Message ],   include_player_ids :   [ 3009e210-3166-11e5-bc1b-db44eb02b120 ]])     Objective-C  1\n2\n3\n4 [ Kontext   postNotification : @{ \n    @ contents   :   @{ @ en :   @ Test Message } , \n    @ include_player_ids :   @[ @ 3009e210-3166-11e5-bc1b-db44eb02b120 ]  } ];", 
            "title": "postNotification"
        }, 
        {
            "location": "/iOS/reference/#clearkontextnotifications", 
            "text": "METHOD  iOS provides a standard way to clear notifications by clearing badge count, thus there is no specific Kontext API call for clearing notifications.", 
            "title": "ClearKontextNotifications"
        }, 
        {
            "location": "/iOS/reference/#setsubscription", 
            "text": "METHOD  You can call this method with false to opt users out of receiving all notifications through Kontext. You can pass true later to opt users back into notifications.     Parameter  Type  Description      enable  BOOL        Swift  1 Kontext . setSubscription ( false )     Objective-C  1 [ Kontext   setSubscription : false ];", 
            "title": "setSubscription"
        }, 
        {
            "location": "/iOS/reference/#email", 
            "text": "", 
            "title": "Email"
        }, 
        {
            "location": "/iOS/reference/#setemail", 
            "text": "METHOD  setEmail  allows you to set the user's email address with the Kontext SDK. We offer several overloaded versions of this method.    Swift  1 Kontext . setEmail ( example@domain.com );     Objective-C  1 [ Kontext   setEmail : @ example@domain.com ];", 
            "title": "setEmail"
        }, 
        {
            "location": "/iOS/reference/#logoutemail", 
            "text": "METHOD  If your app implements logout functionality, you can call  logoutEmail  to dissociate the email from the device:    Swift  1 Kontext . logoutEmail ();     Objective-C  1 [ Kontext   logoutEmail ];", 
            "title": "logoutEmail"
        }, 
        {
            "location": "/iOS/reference/#addemailsubscriptionobserver", 
            "text": "METHOD  We have also added a new email subscription observer to track changes to email subscriptions (ie. the user sets their email or logs out). In order to subscribe to email subscription changes you can implement the following:    Swift  1 Kontext . add ( self   as   OSEmailSubscriptionObserver )     Objective-C  1 [ Kontext   addEmailSubscriptionObserver : self ];     Now, whenever the email subscription changes, this method will be called:    Swift  1\n2\n3 func   onOSEmailSubscriptionChanged ( _   stateChanges :   OSEmailSubscriptionStateChanges !)   {   }     Objective-C  1\n2\n3 -( void ) onOSEmailSubscriptionChanged: ( OSEmailSubscriptionStateChanges   * ) stateChanges   {  }", 
            "title": "addEmailSubscriptionObserver"
        }, 
        {
            "location": "/iOS/reference/#notifications-events", 
            "text": "", 
            "title": "Notifications Events"
        }, 
        {
            "location": "/iOS/reference/#kontexthandlenotificationreceivedblock", 
            "text": "CALLBACK  Called when the app receives a notification while in focus only.   Note+  If you need this to be called when your app is in the background, set content_available to true when you create your notification. The \"force-quit\" state (i.e app was swiped away) is not currently supported.      Parameter  Type  Description      notification  KontextNotification        Swift  1\n2\n3 {   notification   in \n     print ( Received Notification -  \\( notification . payload . notificationID )  -  \\( notification . payload . title ) )  }     Objective-C  1\n2\n3 ^ ( OSNotification   * notification )   { \n     NSLog ( @ Received Notification - %@ - %@ ,   notification . payload . notificationID ,   notification . payload . title );  }", 
            "title": "KontextHandleNotificationReceivedBlock"
        }, 
        {
            "location": "/iOS/reference/#kontexthandlenotificationactionblock", 
            "text": "CALLBACK  Called when the user opens or taps an action on a notification.     Parameter  Type  Description      result  KontextNotificationOpenedResult        Swift   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 {   result   in \n\n     // This block gets called when the user reacts to a notification received \n     let   payload :   OSNotificationPayload   =   result !. notification . payload \n     var   fullMessage   =   payload . body \n\n     //Try to fetch the action selected \n     if   let   additionalData   =   payload . additionalData ,   actionSelected   =   additionalData [ actionSelected ]   as ?   String   { \n         fullMessage   =    fullMessage   +   \\n Pressed ButtonId: \\( actionSelected ) \n     } \n     print ( fullMessage =  \\( fullMessage ) )  }     Objective-C   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26 ^ ( KontextNotificationOpenedResult   * result )   { \n\n    // This block gets called when the user opens or taps an action on a notification \n    KontextNotificationPayload *   payload   =   result . notification . payload ; \n\n    NSString *   messageTitle   =   @ Kontext Example ; \n    NSString *   fullMessage   =   [ payload . body   copy ]; \n\n    if   ( payload . additionalData )   { \n       if   ( payload . title ) \n          messageTitle   =   payload . title ; \n\n       NSDictionary *   additionalData   =   payload . additionalData ; \n\n       if   ( additionalData [ @ actionSelected ]) \n          fullMessage   =   [ fullMessage   stringByAppendingString :[ NSString   stringWithFormat : @ \\n Pressed ButtonId:%@ ,   additionalData [ @ actionSelected ]]]; \n    } \n\n    UIAlertView *   alertView   =   [[ UIAlertView   alloc ] \n                                initWithTitle : messageTitle \n                                      message : fullMessage \n                                     delegate : self \n                            cancelButtonTitle : @ Close \n                           otherButtonTitles : nil ,   nil ]; \n    [ alertView   show ];  }", 
            "title": "KontextHandleNotificationActionBlock"
        }, 
        {
            "location": "/iOS/reference/#kontextnotificationopenedresult", 
            "text": "INTERFACE ELEMENT  The information returned from a notification the user received. Resulting class passed to  KontextHandleNotificationActionBlock .     Class Properties       notification ( KontextNotification );     action ( KontextNotificationAction );|", 
            "title": "KontextNotificationOpenedResult"
        }, 
        {
            "location": "/iOS/reference/#kontextnotification", 
            "text": "INTERFACE ELEMENT  The notification the user received.     Class Properties       payload ( KontextNotificationPayload );     displayType ( KontextNotificationDisplayType );     shown ( BOOL );  True when the user was able to see the notification. False when app is in focus and in-app alerts are disabled, or the remote notification is silent.    silentNotification ( BOOL );  True when the received notification is silent. Silent means there is no alert, sound, or badge payload in the APS dictionary. Requires remote-notification within UIBackgroundModes array of the Info.plist", 
            "title": "KontextNotification"
        }, 
        {
            "location": "/iOS/reference/#kontextnotificationaction", 
            "text": "INTERFACE ELEMENT  The action the user took on the notification.     Class Properties       actionID ( NSString );  The ID associated with the button tapped. NULL when the actionType is NotificationTapped or InAppAlertClosed.    type ( KontextNotificationActionType );  The type of the notification action.", 
            "title": "KontextNotificationAction"
        }, 
        {
            "location": "/iOS/reference/#kontextnotificationactiontype", 
            "text": "INTERFACE ELEMENT  The action type ( NSUInteger Enum ) associated to an KontextNotificationAction object.     NSUInteger Enum Properties       opened     ActionTaken", 
            "title": "KontextNotificationActionType"
        }, 
        {
            "location": "/iOS/reference/#kontextnotificationdisplaytype", 
            "text": "INTERFACE ELEMENT  The way in which a notification was displayed to the user ( NSUInteger Enum ).     NSUInteger Enum Properties  Raw Value       Notification  2  iOS native notification display.    InAppAlert  1  Default UIAlertView display.    None  0  Notification is silent, or app is in focus but InAppAlertNotifications are disabled.", 
            "title": "KontextNotificationDisplayType"
        }, 
        {
            "location": "/iOS/reference/#kontextnotificationpayload", 
            "text": "INTERFACE ELEMENT  Contents and settings of the notification the user received.     Class Properties  Type  Description      notificationID  NSString  Kontext notification UUID    contentAvailable  BOOL  Provide this key with a value of 1 to indicate that new content is available. Including this key and value means that when your app is launched in the background or resumed\u00a0 application : didReceiveRemoteNotification : fetchCompletionHandler : \u00a0is called.    badge  NSInteger  The badge number assigned to the application icon    sound  NSString  The sound parameter passed to the notification. By default set to\u00a0 UILocalNotificationDefaultSoundName .\u00a0 Read more about custom sounds    title  NSString  Title text of the notification    body  NSString  Body text of the notification    subtitle  NSString  iOS 10+\u00a0- subtitle text of the notification    launchUrl  NSString  Web address to launch within the app via a\u00a0 UIWebView    additionalData  NSDictonary  Additional Data add to the notification by you    attachments  NSDictonary  iOS 10+\u00a0- Attachments sent as part of the rich notification    actionButtons  NSArray  Action buttons set on the notification    rawPayload  NSDictonary  Holds the raw APS payload received", 
            "title": "KontextNotificationPayload"
        }, 
        {
            "location": "/iOS/reference/#debug", 
            "text": "", 
            "title": "Debug"
        }, 
        {
            "location": "/iOS/reference/#setloglevel", 
            "text": "METHOD  Enable logging to help debug if you run into an issue setting up Kontext. This selector is static so you can call it before Kontext init. The following options are available with increasingly more information;  ONE_S_LL_NONE ,  ONE_S_LL_FATAL ,  ONE_S_LL_ERROR ,  ONE_S_LL_WARN ,  ONE_S_LL_INFO ,  ONE_S_LL_DEBUG ,  ONE_S_LL_VERBOSE .     Parameter  Type  Description      logLevel  LOG_LEVEL  Sets the logging level to print to the Xcode log    visualLevel  LOG_LEVEL  Sets the logging level to show as alert dialogs.       Swift  1 Kontext . setLogLevel (. LL_DEBUG ,   visualLevel :   . LL_DEBUG )     Objective-C  1 [ Kontext   setLogLevel : ONE_S_LL_DEBUG   visualLevel : ONE_S_LL_DEBUG ];", 
            "title": "setLogLevel"
        }, 
        {
            "location": "/iOS/push-certificate/", 
            "text": "Generate an iOS Push Certificate\n\n\nRequired for all\u00a0iOS\u00a0apps.\n\n\nThe goals of this section are to provision your app with Apple and grant Kontext access to manage your notifications.\n\n\nRequired For Setup\n\n\n\n\nA Kontext Account\n if you do not already have one\n\n\nYour Kontext App Auth Key, available in \nKeys \n IDs\n\n\nA Mac with Xcode 8+. \n\n\n\n\n1. Create Certificate Request Manually\n\n\n1.1\n Open Keychain Access on your Mac OS X system. It may be located in \"Applications\" \n \"Utilities\" \n \"Keychain Access\"\n\n\n1.2\n Select \"Keychain Access\"\n\"Certificate Assistant\"\n\"Request a Certificate From a Certificate Authority...\"\n\n\nIMAGE\n\n\n1.3\n\u00a0Select the \"Save to disk\" option and enter your information in the required fields. This creates a certification request file that will be used later.\n\n\nIMAGE\n\n\n2. Enable Push Notifications and apply the Certification Request to generate Certificate\n\n\n2.1\n Select your app from the \nApple's Developer site\n and press \"Edit\"\n\n\nIMAGE\n\n\n2.2\n Scroll down to the bottom and enable Push Notifications. Press Done, but do not configure either Production or Development certificate.\n\n\nInstead, go to \nAdd iOS Certificate\n and select \"\nApple Push Notification service SSL (Sandbox \n Production)\n\" and click Continue.\n\n\nThis certificate will be applicable to both Sandbox and Production environments, so you do not need a separate key for each one.\n\n\nIMAGE\n\n\n2.3\n Choose an App ID from the App ID pop-up menu, and click Continue.\n\n\n2.4\n Press Continue\n\n\n2.5\n Press \"Choose File..\", select the \"certSigningRequest\" file you saved in step 1, press open, and then press \"Generate\".\n\n\nIMAGE\n\n\n2.6\n\u00a0Press Download to save your certificate\n\n\n3. Creating a Private Key\n\n\n3.1\n Open the .cer file you downloaded in the last step by double clicking on it in Finder.\n\n\nIMAGE\n\n\n3.2\n\u00a0After a few seconds the \"Keychain Access\" program should pop up. Select Login \n My Certificates then right click on your key in the list and select \"Export\"\n\n\nIMAGE\n\n\n3.3\n Give the file a unique name using the \n.p12\n extension, and press save. You will have an option to protect the file with a password. If you add a password, you need to enter this same password on Kontext.\n\n\n4. Upload Your Push Certificate to Kontext\n\n\nIf you haven't already, you should \nset up your Kontext account\n.\n\n\n4.1\n Select your app from the All Apps page in Kontext, then go to \"App Settings\" and press Configure to the right of the Apple iOS Settings.\n\n\nIMAGE\n\n\n4.2\n\u00a0Select the .p12 you exported along with a password if you added one and press Save.\n\n\nIMAGE\n\n\n\n\nTroubleshooting\n\n\nIf you are running into any issues you can try troubleshooting them with our \niOS Troubleshooting", 
            "title": "Generate an iOS Push Cert"
        }, 
        {
            "location": "/iOS/push-certificate/#generate-an-ios-push-certificate", 
            "text": "Required for all\u00a0iOS\u00a0apps.  The goals of this section are to provision your app with Apple and grant Kontext access to manage your notifications.", 
            "title": "Generate an iOS Push Certificate"
        }, 
        {
            "location": "/iOS/push-certificate/#required-for-setup", 
            "text": "A Kontext Account  if you do not already have one  Your Kontext App Auth Key, available in  Keys   IDs  A Mac with Xcode 8+.", 
            "title": "Required For Setup"
        }, 
        {
            "location": "/iOS/push-certificate/#1-create-certificate-request-manually", 
            "text": "1.1  Open Keychain Access on your Mac OS X system. It may be located in \"Applications\"   \"Utilities\"   \"Keychain Access\"  1.2  Select \"Keychain Access\" \"Certificate Assistant\" \"Request a Certificate From a Certificate Authority...\"  IMAGE  1.3 \u00a0Select the \"Save to disk\" option and enter your information in the required fields. This creates a certification request file that will be used later.  IMAGE", 
            "title": "1. Create Certificate Request Manually"
        }, 
        {
            "location": "/iOS/push-certificate/#2-enable-push-notifications-and-apply-the-certification-request-to-generate-certificate", 
            "text": "2.1  Select your app from the  Apple's Developer site  and press \"Edit\"  IMAGE  2.2  Scroll down to the bottom and enable Push Notifications. Press Done, but do not configure either Production or Development certificate.  Instead, go to  Add iOS Certificate  and select \" Apple Push Notification service SSL (Sandbox   Production) \" and click Continue.  This certificate will be applicable to both Sandbox and Production environments, so you do not need a separate key for each one.  IMAGE  2.3  Choose an App ID from the App ID pop-up menu, and click Continue.  2.4  Press Continue  2.5  Press \"Choose File..\", select the \"certSigningRequest\" file you saved in step 1, press open, and then press \"Generate\".  IMAGE  2.6 \u00a0Press Download to save your certificate", 
            "title": "2. Enable Push Notifications and apply the Certification Request to generate Certificate"
        }, 
        {
            "location": "/iOS/push-certificate/#3-creating-a-private-key", 
            "text": "3.1  Open the .cer file you downloaded in the last step by double clicking on it in Finder.  IMAGE  3.2 \u00a0After a few seconds the \"Keychain Access\" program should pop up. Select Login   My Certificates then right click on your key in the list and select \"Export\"  IMAGE  3.3  Give the file a unique name using the  .p12  extension, and press save. You will have an option to protect the file with a password. If you add a password, you need to enter this same password on Kontext.", 
            "title": "3. Creating a Private Key"
        }, 
        {
            "location": "/iOS/push-certificate/#4-upload-your-push-certificate-to-kontext", 
            "text": "If you haven't already, you should  set up your Kontext account .  4.1  Select your app from the All Apps page in Kontext, then go to \"App Settings\" and press Configure to the right of the Apple iOS Settings.  IMAGE  4.2 \u00a0Select the .p12 you exported along with a password if you added one and press Save.  IMAGE   Troubleshooting  If you are running into any issues you can try troubleshooting them with our  iOS Troubleshooting", 
            "title": "4. Upload Your Push Certificate to Kontext"
        }, 
        {
            "location": "/iOS/troubleshoot/", 
            "text": "Troubleshooting iOS\n\n\nNotification Display Issues\n\n\nNotifications are not shown at all when Action Buttons or Media Attachments are added\n\n\nThe below 9 troubleshooting steps only applies to pre-2.4.0 versions of the iOS SDK or if the device is running iOS 8 or 9.\n\nIn order for notifications with buttons to display the following must be true:\n\n\n1.\n You can not force close the app by double tapping the home button and swiping away your app.\n\n\n\n\nThis includes stopping your app from Xcode or disconnecting the device from your Mac after deploying. If you do this you must reopen your app then press the home button to background it.\n\n\nIf this is the case you will see an entry in the device log in Xcode like the following.\n\n\napsd[83] \nWarning\n: Low Priority Push: com.kontext.example - App killed\n\n\n\n\n2.\n Go to \nSettings\n \n \nGeneral\n \n \nBackground App Refresh\n and make sure it is enable for both the device and your app.\n\n\n3.\n Make sure \"Remote notifications\" are checked under Capabilities\nBackground Modes shown in \nstep 2. Add Required Capabilities\n. Note: This is automatic for some plugins like Cordova and Corona.\n\n\n4.\n Remove any other push notifications SDKs from your app.\n\n\n5.\n Development build - After disconnecting your device from your system after deploying the app directly from Xcode you will need to reopen your app so it isn't stuck in the forced close state.\n\n\n6.\n The APNs send priority is lower on these types of notifications. Please allow a few minutes for these to be received.\n\n\n7.\n If you continue to see delivery issues try sending a notification without these options set to confirm there are no networking issues with your iOS device.\n\n\n8.\n If even if the above is ok there can still be a stuck network connect so we recommend toggling your network connection off then back on again.\n\n\n9.\n If all else fails try uninstalling your app and rebooting the device.\n\n\nNotification is shown but media attachments are not displayed\n\n\n1.\n Open your attachment URL in a web browser. Make sure it is a direct link to the image, it can't be part of an HTML page. Also redirects are not supported.\n\n\n2.\n Make sure your URL is HTTPS. HTTP urls will not work unless you set \nNSAppTransportSecurity\n to \nNSAllowsArbitraryLoads\n in your Xcode \n.plist\n.\n\n\n3.\n Make sure your url ends with the correct file extension. If the URL doesn't contain a file extension you can add it as a parameter by adding \n?filetype=file.jpg\n for example to the end of your URL.\n\n\n4.\n If you are using our 2.4.0 native SDK please double check you have correctly added the NotificationServiceExtension noted in step 1 of the \niOS Setup guide\n.\n\n\n5.\n If you correctly added the Kontext Notification Service Extension and rich push notifications (images, buttons) still don't appear, make sure that the \nDeployment Target\n in the Extension service matches the deployment target of your application.\n\n\nNotification is shown but action buttons are not displaying\n\n\n1.\n If you are using our 2.4.0 native SDK please double check you have correctly added the NotificationServiceExtension noted in step 1 of the \niOS Setup guide\n.\n\n\nDebug the Notification Service Extension\n\n\n1.\n Double check that you followed all setup instructions first, please see the SDK docs your are using for more on this.\n\n\n2.\n The 2 debugging lines in the .m source we provide are 2 ways to confirm the notification service extension is running.\n\n\nself\n.\nbestAttemptContent\n.\nbody\n \n=\n \n[\n@\n[Modified] \n \nstringByAppendingString\n:\nself\n.\nbestAttemptContent\n.\nbody\n];\n\n\nThis line will add \"[Modified] \" to the beginning of all your notification bodies. You should see this on all notifications on your device.\n\n\nNSLog\n(\n@\nRunning NotificationServiceExtension\n);\n\n\nThis will add an entry to the device log when the extension is run. You can view this in Xcode under Window \n \"Devices and Simulators\". Select your device on the left and open the log up arrow at the bottom.\n\n\nWe recommend clearing the log before sending a notification to test as it can grow quickly. Copy the log and search for the debug entry \"Running NotificationServiceExtension\".\n\n\nWe don't recommend trying to attach to the extension process with the debugger in Xcode through the Debug menu. Doing so can create issues with it launch so we recommend restarting your device if you have tried doing so.\n\n\nLastly the Notification Service Extension will only run if you have set our Action Buttons, a Media Attachment, or have set mutable content on the notification so make sure your test notification have one of these set.\n\n\n\n\nSwift : No such module 'Kontext'\n\n\nCocoaPods:\n Pods written in Swift should be imported with the \nuse_frameworks!\n, and CocoaPods will complain if you don't do this and try to import the pods in Swift code.\n\n\nManual Import:\n One way to solve your issue is to go into your build settings and defining the \nFramework Search Paths\n to a folder which contains the frameworks in question. If the Kontext framework is placed in your project directory, simply set the framework search path to $(SRCROOT) and set it to recursive.\n\n\n\n\nHow to get a crash log from an iOS device\n\n\nNOTE:\n For your crash to show in the following steps the crash must happen when your device is not connected to your Mac. Connect it after you reproduce the crash.\n\n\n1.\n In Xcode go to \nWindow\n \n \nDevices\n.\n\n\n2.\n Select your device on the left and press the \"View Device Logs\" button.\n\n\n3.\n Sort by \nDate/Time\n to find your log.\n\n\n4.\n Right click on the entry and select \nExport Log\n.\n\n\n5.\n Send it to Kontext support along with details on reproducing the crash.\n\n\n\n\nResetting the iOS Notification Permission Prompt\n\n\niOS 9+\n\n\nPermission is reset when the app is uninstalled.\n\n\nPre-iOS 9\n\n\niOS prompts the user to allow displaying of notifications with a system prompt. Our SDK's default setting is to request permissions as soon as your app is opened. However, we recommend you delay the prompt by disabling \nautoRegister\n and calling register at a later point. \n(See the SDK API that applies to your app for details)\n\n\nDelaying the prompt can get your app better opt-in rates if you prompt after they compete your tutorial. Since iOS remembers the answer to the notification permissions question even after a full reinstall it can be tricky to reset the prompt to test it again so we have written the following instructions below.\n\n\nClear Notification Permission Answer\n\n\n\n\nUninstall your app.\n\n\nReboot the device.\n\n\nSet your system clock ahead 1 day.\n   \n(Do no set your clock over 1 week ahead as you may no longer receive pushes)\n\n\nReboot the device again.\n\n\nReinstall your app and it will prompt you again.\n\n\n\n\nQuick way to test displaying of the prompt\n\n\n\n\nWhen you see the notification permission DO NOT answer it.\n\n\nPower the device off.\n\n\nAfter the device powers back on, fully uninstall then reinstall your app.\n\n\n\n\n\n\nPrevious Push Notifications Disappear\n\n\niOS 7+\n\n\nPrevious push notifications disappear when the user opens the app.\n\n\nThe Kontext SDK will automatically clear previously received push notifications when the app is opened under two conditions:\n\n\n\n\nThe badge number is \n 0\n\n\nThe application was opened from a push notification\n\n\n\n\nThis behavior is caused by our system to clear the badge number. Most app developers want this behavior, however some do not. In order to prevent this from occurring, you can add \nKontext_disable_badge_clearing\n = \nfalse\n in your application's \nInfo.plist\n.\n\n\n\n\nStill facing issues? We'are happy to help\n\n\n\n\n1\n2\n3\n4\n5\n6\nWe answer most support queries in under 4 hours during the week, and under 24 hours on weekends. Simply email us at [support@kontext.in](mailto:support@kontext.in)\n    1. Version of our SDK\n    2. Device OS version\n    3. Xcode crash lock or stack trace of the app       starting and the problem point\n    4. Any other libraries or plugins in your app\n    5. Details on reproducing your problem.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/iOS/troubleshoot/#troubleshooting-ios", 
            "text": "", 
            "title": "Troubleshooting iOS"
        }, 
        {
            "location": "/iOS/troubleshoot/#notification-display-issues", 
            "text": "", 
            "title": "Notification Display Issues"
        }, 
        {
            "location": "/iOS/troubleshoot/#notifications-are-not-shown-at-all-when-action-buttons-or-media-attachments-are-added", 
            "text": "The below 9 troubleshooting steps only applies to pre-2.4.0 versions of the iOS SDK or if the device is running iOS 8 or 9. \nIn order for notifications with buttons to display the following must be true:  1.  You can not force close the app by double tapping the home button and swiping away your app.   This includes stopping your app from Xcode or disconnecting the device from your Mac after deploying. If you do this you must reopen your app then press the home button to background it.  If this is the case you will see an entry in the device log in Xcode like the following.  apsd[83]  Warning : Low Priority Push: com.kontext.example - App killed   2.  Go to  Settings     General     Background App Refresh  and make sure it is enable for both the device and your app.  3.  Make sure \"Remote notifications\" are checked under Capabilities Background Modes shown in  step 2. Add Required Capabilities . Note: This is automatic for some plugins like Cordova and Corona.  4.  Remove any other push notifications SDKs from your app.  5.  Development build - After disconnecting your device from your system after deploying the app directly from Xcode you will need to reopen your app so it isn't stuck in the forced close state.  6.  The APNs send priority is lower on these types of notifications. Please allow a few minutes for these to be received.  7.  If you continue to see delivery issues try sending a notification without these options set to confirm there are no networking issues with your iOS device.  8.  If even if the above is ok there can still be a stuck network connect so we recommend toggling your network connection off then back on again.  9.  If all else fails try uninstalling your app and rebooting the device.", 
            "title": "Notifications are not shown at all when Action Buttons or Media Attachments are added"
        }, 
        {
            "location": "/iOS/troubleshoot/#notification-is-shown-but-media-attachments-are-not-displayed", 
            "text": "1.  Open your attachment URL in a web browser. Make sure it is a direct link to the image, it can't be part of an HTML page. Also redirects are not supported.  2.  Make sure your URL is HTTPS. HTTP urls will not work unless you set  NSAppTransportSecurity  to  NSAllowsArbitraryLoads  in your Xcode  .plist .  3.  Make sure your url ends with the correct file extension. If the URL doesn't contain a file extension you can add it as a parameter by adding  ?filetype=file.jpg  for example to the end of your URL.  4.  If you are using our 2.4.0 native SDK please double check you have correctly added the NotificationServiceExtension noted in step 1 of the  iOS Setup guide .  5.  If you correctly added the Kontext Notification Service Extension and rich push notifications (images, buttons) still don't appear, make sure that the  Deployment Target  in the Extension service matches the deployment target of your application.", 
            "title": "Notification is shown but media attachments are not displayed"
        }, 
        {
            "location": "/iOS/troubleshoot/#notification-is-shown-but-action-buttons-are-not-displaying", 
            "text": "1.  If you are using our 2.4.0 native SDK please double check you have correctly added the NotificationServiceExtension noted in step 1 of the  iOS Setup guide .", 
            "title": "Notification is shown but action buttons are not displaying"
        }, 
        {
            "location": "/iOS/troubleshoot/#debug-the-notification-service-extension", 
            "text": "1.  Double check that you followed all setup instructions first, please see the SDK docs your are using for more on this.  2.  The 2 debugging lines in the .m source we provide are 2 ways to confirm the notification service extension is running.  self . bestAttemptContent . body   =   [ @ [Modified]    stringByAppendingString : self . bestAttemptContent . body ];  This line will add \"[Modified] \" to the beginning of all your notification bodies. You should see this on all notifications on your device.  NSLog ( @ Running NotificationServiceExtension );  This will add an entry to the device log when the extension is run. You can view this in Xcode under Window   \"Devices and Simulators\". Select your device on the left and open the log up arrow at the bottom.  We recommend clearing the log before sending a notification to test as it can grow quickly. Copy the log and search for the debug entry \"Running NotificationServiceExtension\".  We don't recommend trying to attach to the extension process with the debugger in Xcode through the Debug menu. Doing so can create issues with it launch so we recommend restarting your device if you have tried doing so.  Lastly the Notification Service Extension will only run if you have set our Action Buttons, a Media Attachment, or have set mutable content on the notification so make sure your test notification have one of these set.", 
            "title": "Debug the Notification Service Extension"
        }, 
        {
            "location": "/iOS/troubleshoot/#swift-no-such-module-kontext", 
            "text": "CocoaPods:  Pods written in Swift should be imported with the  use_frameworks! , and CocoaPods will complain if you don't do this and try to import the pods in Swift code.  Manual Import:  One way to solve your issue is to go into your build settings and defining the  Framework Search Paths  to a folder which contains the frameworks in question. If the Kontext framework is placed in your project directory, simply set the framework search path to $(SRCROOT) and set it to recursive.", 
            "title": "Swift : No such module 'Kontext'"
        }, 
        {
            "location": "/iOS/troubleshoot/#how-to-get-a-crash-log-from-an-ios-device", 
            "text": "NOTE:  For your crash to show in the following steps the crash must happen when your device is not connected to your Mac. Connect it after you reproduce the crash.  1.  In Xcode go to  Window     Devices .  2.  Select your device on the left and press the \"View Device Logs\" button.  3.  Sort by  Date/Time  to find your log.  4.  Right click on the entry and select  Export Log .  5.  Send it to Kontext support along with details on reproducing the crash.", 
            "title": "How to get a crash log from an iOS device"
        }, 
        {
            "location": "/iOS/troubleshoot/#resetting-the-ios-notification-permission-prompt", 
            "text": "", 
            "title": "Resetting the iOS Notification Permission Prompt"
        }, 
        {
            "location": "/iOS/troubleshoot/#ios-9", 
            "text": "Permission is reset when the app is uninstalled.", 
            "title": "iOS 9+"
        }, 
        {
            "location": "/iOS/troubleshoot/#pre-ios-9", 
            "text": "iOS prompts the user to allow displaying of notifications with a system prompt. Our SDK's default setting is to request permissions as soon as your app is opened. However, we recommend you delay the prompt by disabling  autoRegister  and calling register at a later point.  (See the SDK API that applies to your app for details)  Delaying the prompt can get your app better opt-in rates if you prompt after they compete your tutorial. Since iOS remembers the answer to the notification permissions question even after a full reinstall it can be tricky to reset the prompt to test it again so we have written the following instructions below.  Clear Notification Permission Answer   Uninstall your app.  Reboot the device.  Set your system clock ahead 1 day.\n    (Do no set your clock over 1 week ahead as you may no longer receive pushes)  Reboot the device again.  Reinstall your app and it will prompt you again.   Quick way to test displaying of the prompt   When you see the notification permission DO NOT answer it.  Power the device off.  After the device powers back on, fully uninstall then reinstall your app.", 
            "title": "Pre-iOS 9"
        }, 
        {
            "location": "/iOS/troubleshoot/#previous-push-notifications-disappear", 
            "text": "", 
            "title": "Previous Push Notifications Disappear"
        }, 
        {
            "location": "/iOS/troubleshoot/#ios-7", 
            "text": "Previous push notifications disappear when the user opens the app.  The Kontext SDK will automatically clear previously received push notifications when the app is opened under two conditions:   The badge number is   0  The application was opened from a push notification   This behavior is caused by our system to clear the badge number. Most app developers want this behavior, however some do not. In order to prevent this from occurring, you can add  Kontext_disable_badge_clearing  =  false  in your application's  Info.plist .   Still facing issues? We'are happy to help   1\n2\n3\n4\n5\n6 We answer most support queries in under 4 hours during the week, and under 24 hours on weekends. Simply email us at [support@kontext.in](mailto:support@kontext.in)\n    1. Version of our SDK\n    2. Device OS version\n    3. Xcode crash lock or stack trace of the app       starting and the problem point\n    4. Any other libraries or plugins in your app\n    5. Details on reproducing your problem.", 
            "title": "iOS 7+"
        }
    ]
}